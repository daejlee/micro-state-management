# 10. React Tracked

속성 감지를 기반으로 자동으로 리렌더링 최적화를 수행하는 상태 사용 추적 라이브러리  
상태 관리 기능을 제공하지는 않지만 렌더링 최적화 기능을 제공하며, 이를 **상태 사용 추적**이라고 한다.

다른 상태 관리 라이브러리와 함께 사용할 수 있다.

## React Tracked 이해하기

React Tracked에서 상태 사용 추적의 사용 사례 중 하나는 리액트 컨텍스트이다. 주로 리액트 컨텍스트를 대체할 용도로 사용된다.

```ts
const NameContext = createContext([{ firstName: "react", laseName: "hooks" }, () => {}]);

const useFirstName = () => {
  const [{ firstName }] = useContext(NameContext);
  return firstName;
};
```

이렇게 하면, lastName만 수정했을 때에도 firstName을 사용하는 컴포넌트에서 리렌더링이 발생할 수 있다.

```ts
const useFirstName = () => {
  const [{ firstName }] = useTracked();
  return firstName;
};
```

React Tracked를 사용하면 `useContext(NameContext)`를 대신해서 쓸 수 있는 `useTracked`라는 훅을 정의할 수 있다.

- useTracked는 상태를 proxy를 감싸고 사용을 추적한다.

내부에서 상태 사용을 추적하고 렌더링을 자동으로 최적화한다.

## useState와 함께 사용하기

```ts
import { useState } from "react";
import { createContainer } from "react-tracked";

const useValue = () => useState({ count: 0, text: "hello" });

const { Provider, useTracked } = createContainer(useValue);

const Counter = () => {
  const [state, setState] = useTracked();
  const inc = () => {
    setState((prev) => ({ ...prev, count: prev.count + 1 }));
  };
  ...
}

const App = () => (
  <Provider>
    <div>
      <Counter />
    </div>
  </Provider>
);
```

useState를 전역적으로 사용하여 전역 상태를 만들고 React Tracked를 사용해 useState 에서 만든 상태를 proxy로 감싸고 사용을 추적한다.

- React Tracked의 createContainer를 사용하면 Provider과 useTracked가 반환된다.

useTracked에 의해 반환된 state객체는 추적이 가능한 객체이다. 따라서 useTracked훅은 접근된 속성이 변경된 경우에만 리렌더링을 감지한다.

만약 위 코드에서 text만 변경된다면 Counter 컴포넌트는 리렌더링되지 않는다.

## useReducer과 함께 사용하기

```ts
const useValue = () => {
  type State = { count: number; text: string };
  type Action = { type: "INC" } | { type: "SET_TEXT"; text: string };
  const [state, dispatch] = useReducer(
    (state: State, action: Action) => {
      if (action.type === "INC") {
        return { ...state, count: state.count + 1 };
      }
      if (action.type === "SET_TEXT") {
        return { ...state, text: action.text };
      }
      throw new Error("unknown action type");
    },
    { count: 0, text: "hello" }
  );
  useEffect(() => {
    console.log("latest state", state);
  }, [state]);
  return [state, dispatch] as const;
};

const { Provider, useTracked } = createContainer(useValue);

const Counter = () => {
  const [state, dispatch] = useTracked();
  const inc = () => dispatch({ type: "INC" });
  ...
}

const TextBox = () => {
  const [state, dispatch] = useTracked();
  const setText = (text: string) => {
    dispatch({ type: "SET_TEXT", text });
  };
  ...
}
```

useState와 마찬가지로 전역 상태로 사용할 useValue 내부를 useReducer로 만들어 사용한다.

useValue가 state와 dispatch가 담긴 튜플을 반환하므로 useTracked도 state와 dispatch를 반환한다.

Counter 컴포넌트는 INC 타입 디스패치만 사용하니, count 상태만 참조하고, TextBox는 text 상태만 참조한다.

React Tracked가 리렌더링을 최적화할 수 있는 이유는 상태 사용 추적뿐만 아니라 use-context-selector라는 내부 라이브러리 덕분이다.

- use-context-selector는 selector 함수를 이용해 컨텍스트 값을 구독하고, 이 구독을 통해 리액트 컨텍스트의 제약을 우회한다.

## React Redux와 함께 사용하기

React Treacked는 리액트 컨텍스트를 사용하지 않는 경우를 위해 createTrackedSelector라는 저수준 함수를 제공한다.

- 인자로는 useSelector를 받고, useTrackedState 훅을 반환한다.

```ts
type State = { count: number; text: string };
type Action = { type: "INC" } | { type: "SET_TEXT"; text: string };

const initialState: State = { count: 0, text: "hello" };
const reducer = (state = initialState, action: Action) => {
  if (action.type === "INC") {
    return { ...state, count: state.count + 1 };
  }
  if (action.type === "SET_TEXT") {
    return { ...state, text: action.text };
  }
  return state
};

const store = createStore(reducer);
const useTrackedState = createTrackedSelector<State>(useSelector);

const Counter = () => {
  const dispatch = useDispatch();
  const { count } = useTrackedState();
  const inc = () => dispatch({ type: "INC" });
  ...
}
```

React Redux는 useSelector 훅을 제공한다.

useSelector를 사용하면 개발자가 리렌더링 최적화를 위해 더 세세하게 제어할 수 있고, 그만큼 책임도 많아지게 되는데, useTrackedState를 같이 사용하면 훅이 자동으로 리렌더링을 제어해준다.
