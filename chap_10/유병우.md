# 10. React Tracked

React Tracked 또한 Proxy API를 내부적으로 사용하여 다이시 씨가 만든 상태관리 라이브러리이다.

## Context API

기존 Context API는 여러 상태를 가질때, 예를들어 `age`, `name`이 하나의 Context에 있다면 `age`가 변경되어도 `name`만 사용하는 컴포넌트가 리렌더링될 수 있었다.
그래서 context를 `reduceRight`를 사용하여 여러 개의 context로 나누는 방법이 사용되었다.

그러나 React Tracked의 `createContainer`를 사용하면 하나의 Provider안에서도 쉽게 관리할 수 있다.

```js
const { Provider, useTracked } = createContainer(() => {
  const [state, setState] = useState({ name: "John", age: 20 });
  return [state, setState];
});

// name을 사용하는 컴포넌트
const NameDisplay = () => {
  const [state] = useTracked();
  console.log("NameDisplay가 리렌더링되었습니다!");
  return <p>Name: {state.name}</p>;
};

// age를 사용하는 컴포넌트
const AgeDisplay = () => {
  const [state] = useTracked();
  console.log("AgeDisplay가 리렌더링되었습니다!");
  return <p>Age: {state.age}</p>;
};

// setState를 사용하는 컴포넌트
const Controls = () => {
  const [, setState] = useTracked();
  const setName = (name) => setState((s) => ({ ...s, name }));
  const setAge = (age) => setState((s) => ({ ...s, age }));
  return (
    <>
      <button onClick={() => setName("Jane")}>Change Name</button>
      <button onClick={() => setAge(25)}>Change Age</button>
    </>
  );
};
```

Name, Age는 각각 상태만 구독하여 하나가 변경되어도 다른 컴포넌트에 영향을 주지 않는다.

## useReducer와의 연동

useState를 createContainer에 넣을 수 있지만, useReducer를 사용하여 상태를 관리할 수도 있다.

```js
const initialState = { name: "John", age: 20 };

function reducer(state, action) {
  switch (action.type) {
    case "SET_NAME":
      return { ...state, name: action.name };
    case "SET_AGE":
      return { ...state, age: action.age };
    default:
      throw new Error();
  }
}

const { Provider, useTracked } = createContainer(() => {
  return useReducer(reducer, initialState);
});

const NameDisplay = () => {
  const [state] = useTracked();
  return <p>Name: {state.name}</p>;
};

const Controls = () => {
  const [, dispatch] = useTracked();
  return (
    <>
      <button onClick={() => dispatch({ type: "SET_NAME", name: "Jane" })}>
        Change Name
      </button>
      <button onClick={() => dispatch({ type: "SET_AGE", age: 25 })}>
        Change Age
      </button>
    </>
  );
};
```

useState에서는 setState를 `useTracked`의 1번째 인덱스로, useReducer에서는 dispatch를 1번째 인덱스로 사용하면 된다.

## React Redux와의 연동

`createContainer`는 순수히 react에서 제공하는 `useState`, `useReducer`를 기반으로한다. React Redux까지의 연동성도 좋은데 이는 `createTrackedSelector`를 통해 가능하다.

> 다이시 카도는 React Redux를 확실히 좋아하는 게 분명하다. 그러면 React Redux를 좀 책에서 소개해줬어야지...

```js
import { useSelector, useDispatch } from "react-redux";
import { createTrackedSelector } from "react-tracked";

// 1. react-redux의 useSelector를 기반으로 추적용 셀렉터 훅을 생성
const useTrackedState = createTrackedSelector(useSelector);

// 가정: Redux 스토어의 state는 { user: { name: 'John', age: 20 } } 형태
const NameDisplay = () => {
  // 2. useSelector 대신 useTrackedState 사용
  const state = useTrackedState();
  const dispatch = useDispatch();

  const setName = (name) => dispatch({ type: "SET_NAME", name });
  return (
    <>
      <p>Name: {state.user.name}</p>
      <button onClick={() => setName("Jane")}>Change Name</button>
    </>
  );
};

const AgeDisplay = () => {
  const state = useTrackedState();
  const dispatch = useDispatch();

  const incAge = () => dispatch({ type: "SET_AGE", age: state.user.age + 1 });
  return (
    <>
      <p>Age: {state.user.age}</p>
      <button onClick={incAge}>Increase Age</button>
    </>
  );
};
```

기존 React Redux에서는 useSelector에서 특정 상태의 애트리뷰트를 가져와야했으나(`useSelector((state) => state.user.name)`와 같이) react-tracked에서는 전체 상태를 선택하고, 필요한 애트리뷰트만 사용하는 방식으로 변경할 수 있다.

## createContainer 내부 동작

`createContainer`의 내부동작은 어떻게 될까? 대충 Proxy API를 쓸 것 같으나 간단하게 [코드](https://github.com/dai-shi/react-tracked/blob/main/src/createContainer.ts#L35)를 보고 써봤다.

```js
// 라이브러리 내부 개념
function createContainer(useValueHook) {
  // 1. 내부적으로 사용할 '비공개' Context를 생성
  const InternalContext = createContext();

  const Provider = ({ children, ...props }) => {
    // 사용자가 전달한 상태 로직 훅(useState, useReducer)을 실행
    const [state, update] = useValueHook(props);

    // state와 update 함수를 함께 value로 전달합니다.
    // (실제 코드는 성능을 위해 StateContext와 UpdateContext로 분리)
    const contextValue = { state, update };

    return (
      <InternalContext.Provider value={contextValue}>
        {children}
      </InternalContext.Provider>
    );
  };

  const useTracked = () => {
    // Provider로부터 state와 update 함수 가져오기
    const { state, update } = useContext(InternalContext);

    // 실제 코드에서는 `createTrackedSelector(useSelector(...))`를 통해 구현
    // 1. state 변경에 대한 구독을 설정
    // 2. state를 Proxy로 감싸서 속성 접근을 추적
    // 3. 추적된 속성이 변경되었을 때만 리렌더링을 허용
    const trackedState = useTrackedStateWithProxy(state);

    // 최종적으로 [추적된 상태, 업데이트 함수]를 배열 형태로 반환
    return [trackedState, update];
  };

  return {
    Provider,
    useTracked,
  };
}
```
