# 10장. 사용 사례 시나리오 4: React Tracked

React Tracked는 React Context로 전파되는 상태를 그대로 사용하지만,  
실제로 컴포넌트가 사용한(읽은) 필드만 추적한다.

기본적으로, `createContainer()`, `useTracked()` 함수를 사용한다.

## useState, useReducer와 함께 React Tracked 사용하기

### useState

```tsx
import { createContainer } from 'react-tracked';
import { useState } from 'react'

const useValue = () => useState({ count: 0, text: 'hello' });
const { Provider, useTracked } = createContainer(useValue);

function Counter() {
  const [state, setState] = useTracked();        
  // state.count만 읽으면 text 변경에 리렌더되지 않음

  return (
    <>
      <div>count: {state.count}</div>
      <button 
        onClick={() => setState(s => ({ ...s, count: s.count + 1 }))}
      >
        +1
      </button>
    </>
  );
}

function TextBox() {
  const [state, setState] = useTracked();        

  return (
    <input
      value={state.text}
      onChange={e => setState(s => ({ ...s, text: e.target.value }))}
    />
  );
}

export default function App() {
  return (
    <Provider>
      <Counter />
      <TextBox />
    </Provider>
  );
}
```

### useReducer

액션 기반으로 업데이트를 하거나, 상태를 변경하는 로직을 분리하려면 다음과 같이 useReducer와 함께 사용할 수도 있다.

```tsx
import { createContainer } from 'react-tracked';
import { useReducer } from 'react';

type State = { count: number; text: string };
type Action = { type: 'inc' } | { type: 'setText'; text: string };

function reducer(s: State, a: Action): State {
  switch (a.type) {
    case 'inc': return { ...s, count: s.count + 1 };
    case 'setText': return { ...s, text: a.text };
  }
}

const useValue = () => useReducer(reducer, { count: 0, text: 'hello' });
const { Provider, useTracked } = createContainer(useValue);

function Counter() {
  const [state, dispatch] = useTracked();        
  // state.count만 접근

  return (
    <>
      <div>count: {state.count}</div>
      <button onClick={() => dispatch({ type: 'inc' })}>+1</button>
    </>
  );
}

function TextBox() {
  const [state, dispatch] = useTracked();
  return (
    <input
      value={state.text}
      onChange={e => dispatch({ type: 'setText', text: e.target.value })}
    />
  );
}
```

## React Redux와 함께 React Tracked 사용하기

React Tracked의 `createTrackedSelector`로 `useSelector`를 감싸, 선택한 상태 객체 내에서도 **접근(실제 사용)한 필드만 추적**해 리렌더링을 최적화 하는 것이 가능하다.

```tsx
import { createTrackedSelector } from 'react-tracked';
import { useSelector, useDispatch } from 'react-redux';

// tracked selector 훅 생성
const useTrackedSelector = createTrackedSelector(useSelector);

function Counter() {
  const state = useTrackedSelector();       
  // state.counter.value 읽음  
  const dispatch = useDispatch();

  return (
    <>
      <div>count: {state.counter.value}</div>
      <button onClick={() => dispatch({ type: 'counter/increment' })}>+1</button>
    </>
  );
}

function TextBox() {
  const state = useTrackedSelector();         
  // state.text.value만 읽음
  const dispatch = useDispatch();

  return (
    <input
      value={state.text.value}
      onChange={e => dispatch({ type: 'text/set', payload: e.target.value })}
    />
  );
}
```

## React Tracked의 장단점

장점으로는,

1. 기존 훅들, React-redux 기반으로도 필드 단위의 리렌더링 최적화학 가능하다는 것이다.
2. useContext 대신 useTracked 로 교체하면 끝!


단점은,

1. 아무래도 생태계 부족...
2. React 외부에선 사용 불가

