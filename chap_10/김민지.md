# 10. 사용 사례 시나리오 4: React Tracked

React Tracked 라이브러리는 사용법이 크게 두 가지가 존재한다.

### 1. 컨텍스트 대체 용도로 사용하기

### 2. Redux와 함께 사용하기

> ## React Tracked

- 상태 관리 기능을 제공하지는 않고, 렌더링 최적화 기능(상태 사용 추적)을 제공한다.

## 1. 컨텍스트 대체할 용도로 useState, useReducer와 함께 사용하기

```javascript
const { Provider, useTracked } = createContainer(() => useState({count: 0, text: ""});

const Counter = () => {
  const [state, setState] = useTracked();

  return <div>{state.count}</div>
}

const App = () => {
  <Provider>
    <Counter />
  </Provider>
}
```

- state.count값이 바뀔 때만 Counter를 리렌더링 한다.
- 이는 상태 추적 기능 때문인데, 즉 React Tracked 내부에서 사용되는 [context-selector](https://www.npmjs.com/package/use-context-selector) 덕분이다.

## 2. Redux와 함께 사용하기

```javascript
const useTrackedState = createTrackedSelector(useSelector);

const Counter = ({ showCount }: { showCount: number }) => {
  const dispatch = useDispatch();
  const state = useTrackedState();

  return (
    <div>
      {state.text}
      {showCount && state.count}
    </div>
  );
};

const App = () => {
  <Provider store={store}>
    <Counter showCount={false} />
  </Provider>;
};
```

- return에서 보여지는 것이 바뀔 때 자동으로 리렌더링 된다.
- 예시에서 App의 Counter는 state.count가 바뀔때는 리렌더링 되지 않고, text가 바뀔 때만 리렌더링 된다.
- selector를 사용할 때는 개발자가 직접 리렌더링 최적화할 요소를 제어해야 하는데, useTrackedState를 사용하면 훅이 자동으로 리렌더링을 제어해준다.
  - 이는 [proxy-compare](https://www.npmjs.com/package/proxy-compare) 덕분이다.
  - proxy-compare -> createTrackedSelector, createTrackedSelector + context-selector -> createContainer

- createTrackedSelector는 선택자를 직접 받아 전역 상태를 만들기 위해 사용한다.
