# 사용 사례 10장

React Treaacked 는 속성 감지를 기반으로 자동으로 렌더링 최적화를 수행하는 상태 사용 추적 라이브러리를 의미한다. 이는 Valtio 와 동일하게 리렌더링 제거 기능을 수행합니다. React Tracked 는 다른 상태 관리 라이브러리와 함께 사용할 수 있다. 주로 상태 관리를 위해 useState 나 useReducer 를 사용하지만, Redux, Zustand 및 다른 유사한 라이브러리와도 사용할 수 있습니다.

## React Tracked

react-trackted 는 상태 관리 기능을 제공하지는 않지만 렌더링 최적화 기능을 제공합니다. 이 기능을 상태 사용 기능 추적이라고 합니다.

React Tracked 에서 상태 사용 추적 사용 사례중 하나는 리액트 컨텍스트이므로 리액트 컨텍스트가 어떻게 동작하는지 다시한번 확인한다.

```js
// 기존 useReducer를 감싸 트래킹 컨테이너로 전환
const { Provider, useTrackedState, useUpdate } = createContainer(() =>
	React.useReducer(reducer, initial)
);

export default function App() {
	return (
		<Provider>
			<CountView />
			<IncButton />
			<RenameButton />
		</Provider>
	);
}

function CountView() {
	const state = useTracked(); // React Tracked 를 사용
	return <span>{state.count}</span>; // count만 읽음 → count 변경 때만 리렌더
}
```

React Tracked 가 리렌더링을 최적화 할 수 있는 이유는 상태 사용 추적 뿐만 아니라 useContext-selector 라는 내부 라이브러리 덕분이다. 이 라이브러리의 selector 함수를 사용해 컨텍스트 값을 구독 할 수 잇다. 이 구독을 통해 리액트 컨텍스트의 제약을 우회합니다.

### use-context-selector로 컨텍스트 제약을 어떻게 우회하나?

React의 기본 useContext는 Provider의 value 레퍼런스가 바뀌면 트리 안 모든 소비자가 리렌더 대상이 됩니다(실제로 그 값 일부만 필요하더라도). use-context-selector는 두 가지 트릭으로 이 제약을 피해갑니다:

- 셀렉터 + 동등성 비교: 각 소비자가 **selector(contextValue)**로 필요한 조각만 뽑아 구독하고, 이전 선택값과 Object.is로 비교해 변화가 없으면 재렌더를 생략합니다(내부적으로 useSyncExternalStore(WithSelector) 패턴 사용).

- 안정(stable) 컨텍스트 값 + 구독(store) 설계: 컨텍스트에는 큰 상태 객체 대신 구독 가능한 스토어를 전달하고, 실제 변경 알림은 스토어가 구독자에게만 브로드캐스트합니다. 이렇게 하면 Provider가 매번 거대한 값을 재전달하지 않아 광역 리렌더 브로드캐스트를 우회합니다.

A. 기본 컨텍스트(문제점 시연)

```js
import React from "react";

const Ctx = React.createContext({ count: 0, text: "hi" });

function Count() {
	const { count } = React.useContext(Ctx); // Provider value가 바뀌면 항상 리렌더
	return { count };
}

function Text() {
	const { text } = React.useContext(Ctx);
	return { text };
}

export default function App() {
	const [state, setState] = React.useState({ count: 0, text: "hi" });
	return (
		<Ctx.Provider value={state}>
			<button onClick={() => setState((s) => ({ ...s, text: s.text + "!" }))}>
				text!
			</button>
		</Ctx.Provider>
	);
}
```

여기서 text만 바꿔도 Count와 Text 둘 다 리렌더 대상이 됩니다(동일 레퍼런스 변경 브로드캐스트 때문).

B. use-context-selector 적용(선택 구독 + 우회)

```js
import React from "react";
import { createContext, useContextSelector } from "use-context-selector";

// 1) 라이브러리의 createContext 사용 (내부적으로 구독 가능한 스토어를 운용)
const Ctx = createContext(null);

function Provider({ children }) {
	const [state, setState] = React.useState({ count: 0, text: "hi" });
	// 실제 구현은 라이브러리가 안전한 구독 흐름을 제공. 여기선 단순 전달만 표기
	return <Ctx.Provider value={{ state, setState }}>{children}</Ctx.Provider>;
}

function Count() {
	// 2) 필요한 조각만 선택 구독 → count가 바뀔 때만 리렌더
	const count = useContextSelector(Ctx, (v) => v.state.count);
	const setState = useContextSelector(Ctx, (v) => v.setState);
	return (
		<button onClick={() => setState((s) => ({ ...s, count: s.count + 1 }))}>
			{count}
		</button>
	);
}

function Text() {
	const text = useContextSelector(Ctx, (v) => v.state.text); // text만 구독
	const setState = useContextSelector(Ctx, (v) => v.setState);
	return (
		<button onClick={() => setState((s) => ({ ...s, text: s.text + "!" }))}>
			{text}
		</button>
	);
}
```

Count는 count만, Text는 text만 선택적으로 구독합니다.
Provider가 업데이트되더라도, 셀렉터 결과가 바뀌지 않은 소비자는 재렌더를 건너뜁니다.
