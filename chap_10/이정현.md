# 10 - 사용 사례 시나리오 4: React Tracked

- Valtio와 같은 자동 렌더링 최적화를 수행하는 상태 사용 추적 라이브러리
  - 상태 관리 기능 ❌
  - 렌더링 최적화 기능 ⭕️
- 다른 상태 관리 라이브러리와 함께 사용 가능

# React Tracked 이해하기

```tsx
const NameContext = createContext([{ firstName: "react", laseName: "hooks" }, () => {}]);

const useFirstName = () => {
  const [{ firstName }] = useContext(NameContext);
  return firstName;
};
```

- `lastName` 변경 시 새로운 컨텍스트 값이 전파되어 리렌더링이 발생한다
- `firstName`이 변경될 때만 리렌더링이 발생하는 것이 바람직하며, Proxy로 실현 가능하다

```tsx
const useFirstName = () => {
  const [{ firstName }] = useTracked();
  return firstName;
};
```

- `useContext(NameContext)`와 사용법이 같지만 내부에서 상태를 추적하고 렌더링을 최적화하는 `useTracked`를 정의
  - 상태를 Proxy로 감싸고 사용을 추적
- `Valtio`, `React tracked`는 `proxy-compare`라는 내부 라이브러리를 사용하여 상태 사용 추적 기능을 동일하게 사용한다

# useState와 함께 사용하기

- `useState` 기반으로 만든 상태를 전역처럼 쓰되, `React Tracked`이 내부적으로 Proxy를 사용하여 실제로 읽은 부분만 추적
- `createContainer`로 만든 `Provider`를 통해 전역 상태 공유
- `useTracked()` → `[state, setState]` 구조 반환
- `state` 일부만 바뀌어도 해당 컴포넌트만 리렌더링

```tsx
const useValue = () => useState({ count: 0, text: "hello" });
const { Provider, useTracked } = createContainer(useValue);

const Counter = () => {
  const [state, setState] = useTracked();
  const inc = () => setState((p) => ({ ...p, count: p.count + 1 }));
  return (
    <>
      count: {state.count} <button onClick={inc}>+1</button>
    </>
  );
};
```

→ 간단한 전역 상태 관리 + 자동 리렌더링 최적화

# useReducer와 함께 사용하기

- 상태 업데이트 로직을 `reducer`로 관리
- `state` 객체 전체를 리턴하더라도, 컴포넌트가 실제로 읽는 속성만 추적해서 리렌더링
- `useTracked()` → `[state, dispatch]` 구조 반환
- 액션 기반으로 상태 변경

```tsx
const useValue = () => {
  const [state, dispatch] = useReducer(reducer, { count: 0, text: "hello" });
  return [state, dispatch] as const;
};
const { Provider, useTracked } = createContainer(useValue);

const Counter = () => {
  const [state, dispatch] = useTracked();
  const inc = () => dispatch({ type: "INC" });
  return (
    <>
      count: {state.count} <button onClick={inc}>+1</button>
    </>
  );
};
```

→ 전역 상태 + 액션 기반 업데이트를 하면서 React Tracked의 속성 추적 기능으로 최소한의 리렌더링

# React Redux와 함께 사용하기

- Redux + `useSelector`는 선택한 상태 값이 변할 때마다 컴포넌트가 리렌더링되지만, React Tracked의 `createTrackedSelector`를 쓰면 컴포넌트에서 실제로 읽은 값만 추적

```tsx
const useTrackedState = createTrackedSelector<State>(useSelector);

const Counter = () => {
  const dispatch = useDispatch();
  const { count } = useTrackedState();
  const inc = () => dispatch({ type: "INC" });
  return (
    <>
      count: {count} <button onClick={inc}>+1</button>
    </>
  );
};
```

→ Redux의 예측 가능성과 개발 생산성 + React Tracked의 렌더링 최적화 결합

# React Tracked의 목적

1. 컨텍스트 사용 사례 대체
2. 다른 라이브러리에서 제공하는 선택자 훅 향상시키기
