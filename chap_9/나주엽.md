# 9장. 사용 사례 시나리오 3: Valito

Valtio는 변경 가능한 갱신 모델(mutating update model)을 기반으로 하는 전역 상태 관리 라이브러리이다.  
Valtio는 **상태 사용 추적(state usage tracking)**이라는 기법을 통해 자동으로 렌더링을 최적화 한다.

이를 통해, 개발자가 직접 작성할 코드의 양을 줄일 수 있다.

> 기본적인 사용법은 Zustand와 유사해 생략한다.

## 프락시를 활용한 변경 감지 및 불변 상태 생성하기

Valtio는 proxy를 사용해 변경 가능한 객체를 생성한다.  
하지만, **스냅샷(Snapshot)**이라 불리는 불변 객체를 생성할 수도 있다.

아래와 같이 변경 가능 객체 그리고, 불변 객체를 생성할 수 있다.

```ts
import { proxy, snapshot } from "valtio";

// 변경이 가능한 객체
const state = proxy({ count: 0 });

// 불변 객체
const snap1 = snapshot(state);
// 위와 같이 snapshot() 함수로 생성된 객체는 Object.freeze() 와 유사하게 변경이 불가능하다.

// 보통은 아래와 같이 state 를 불변객체로 만들어서 사용한다.
const Counter = () => {
  const snapshot = useSnapshot(state);

  const inc = () => ++state.count;

  return (
    <>
      {snap.count}
      <button onClick={inc}>+1</button>
    </>
  );
};
```

proxy와 snapshot 함수는 중첩된 객체에 대해서도 작동한다.

```ts
const state2 = proxy({
  obj1: { c: 0 },
  obj2: { c: 0 },
});

const snap21 = snapshot(state2);

++state2.obj1.c;

const snap22 = snapshot(state2);
```

이때, `snap21.obj2`와 `snap22.obj2`의 참조가 동일하다. 즉, 같은 메모리 공간이 공유된다.  
Valtio는 필요한 경우에만 스냅샷을 생성해 메모리 사용을 최적화한다.  
(개발자의 별도 고민이나 코드 작성이 없이 가능하다.)

## 프록시를 활용한 리렌더링 최적화

그렇다면, Valtio에서는 어떻게 리렌더링을 최적화하는지 알아보자.

`proxy()` 함수는 자바스크립트의 Proxy API를 활용해 상태 객체를 감싼 반응형 상태 그 자체이다.  
어떤 필드가 읽히는지(사용되는지), 어떤 필드가 변경되는지를 감지한다.  
변경이 발생하면, 해당 필드를 구독중인 컴포넌트에게 알린다.

`useSnapshot()` 함수는 내부적으로 `snapshot()` 함수를 호출해, 읽기 전용 상태를 생성한다.  
이때, 어떤 필드가 읽혔는지를 추적해 상태 객체 전체가 아닌 **특정 필드 단위**로 구독을 설정한다.

즉, 상태 객체 전체가 아닌 사용하는 필드 단위 구독을 설정하므로, 리렌더링을 자동으로 최적화한다.

## Valtio의 장단점

우선 장점,

1. `++state.count` 처럼 별도의 불변성을 관리하지 않고, 상태를 변경할 수 있다. 즉, JS 객체를 다루듯 상태를 조작하면 된다.

2. 필드 단위 구독을 하기 때문에, 큰 전역 상태를 관리하기도 좋다.
3. JS Proxy API 기반이기 때문에, React 외부에서도 동작한다.
4. 매우 간단한 구조를 가진다.

단점은,

1. 명시적인 액션이 없어, 상태 변경이나 추적이 힘들다.
2. Proxy 내부 동작을 확인하기 어렵다. 즉, 디버깅의 난이도, 복잡도가 올라간다.
