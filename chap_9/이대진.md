# Valtio

Valtio는 변경 가능한 갱신 모델을 기반으로 하는 라이브러리다. 모듈 상태용으로 사용되며, 리액트와의 통합을 위해 Valtio는 프록시를 사용해 변경 불가능한 스냅숏을 가져온다.

프록시를 활용해 자동으로 리렌더링을 최적화한다. 선택자가 필요하지 않고 자동 렌더링 최적화는 “상태 사용 추적(state usage tracking)”이라는 기법을 기반으로 한다. 상태의 어느 부분이 사용되는지 감지할 수 있고, 사용 부분이 변경될 경우만 리렌더링되도록 할 수 있다.

## Valtio 살펴보기

모듈 상태에 쓰인다는 점에서 Zustand와 동일하다.

상태를 갱신할 때 setState를 쓴다. 왜? 상태를 불변으로 갱신하고 싶기 때문.

```tsx
moduleState = Object.assign({}, moduleState, {
  count: moduleState.count + 1,
});

// 만약 불변 규칙을 따르지 않아도 된다면?..
++moduleState.count; // 이런 것도 가능할 것이다.
```

참 편하겠지요?~ 프록시를 사용하면 구현할 수 있다. 프록시는 JS의 특수 객체로 객체 연산 감지를 위한 핸들러를 만드는 데 활용할 수 있다.

```tsx
// 첫 번째 인수는 객체, 두 번째 인수는 핸들러를 담는 컬렉션 객체
const proxyObject = new Proxy(
  {
    count: 0,
    text: 'hello',
  },
  {
    set: (target, prop, value) => {
      console.log('start setting', prop);
      target[prop] = value;
      console.log('end setting', prop);
    },
  }
);
```

set 핸들러는 객체의 값이 갱신되려고 할 때 실행된다. 개념적으로 프록시는 모든 변경을 감지할 수 있기 때문에 기술적으로 setState와 유사한 동작을 수행할 수 있다. Valtio는 프록시로 상태 변경을 감지하는 녀석이다.

## 프록시를 활용한 변경 감지 및 불변 상태 생성하기

Valtio는 프록시로 변경 가능한 객체에서 변경 불가능한 객체를 생성한다. 이 불변 객체를 스냅샷이라고 한다.

```tsx
import { proxy } from 'valtio';
const state = proxy({ count: 0 }); // 가변 객체 생성

import { snapshot } from 'valtio';
const snap1 = snapshot(state); // 불변 객체 생성, Object.freeze로 동결된 상태

++state.count;
const snap2 = snapshot(state); // snap1과 snap2는 불변이니비교할 수 있다.
```

proxy와 snapshot 함수는 중첩 객체에 대해서도 작동하고, 스냅샷 생성을 최적화한다. 이 말은 즉 snapshot 함수는 속성이 변경될 때만 새 스냅샷을 생성한다.

```tsx
const state2 = proxy({
  obj1: { c: 0 },
  obj2: { c: 0 },
});
const snap21 = snapshot(state2);
++state2.obj1.c;
const snap22 = snapshot(state2);
// snap21 !== snap22임. 다만 snap21.obj2 === snap22.obj2이다. 유지된다.
```

이 말은 snap21.obj2와 snap22.obj2의 참조가 동일하다는 것을 의미하고, 메모리를 공유한다는 뜻이다. 이런 최적화는 Zustand에서도 수행할 수 있지만 새로운 불변 상태를 적절하게 생성하는 것은 개발자의 책임이다.

<aside>

    💡새 불변 상태를 적절하게 생성하는 것이 개발자의 책임이다.
    이게 무슨 말일까. 만약 이 최적화를 Zustand에서 하고 싶었다면 바뀌지 않은 부분들을 직접 추적해서 한땀한땀 불변 객체를 만들어야 한다는 말인 것 같다.

</aside>

대조적으로 Valtio는 최적화를 내부에서 실행하니, 새 불변 상태를 생성하는 책임에서 자유롭다.

## 프록시를 활용한 리렌더링 최적화

6장의 속성 접근 감지 절에서 배운 리렌더링 최적화 패턴이다. `useSnapshot`을 사용한다.

```tsx
const state = proxy({
  count1: 0,
  count2: 0,
});

const Counter1 = () => {
  // useSnapshot 반환 값의 변수명을 snap으로 설정하는것이 관례
  const snap = useSnapshot(state);
  const inc = () => ++state.count1;
  ...
}

const Counter2 = () => {
  const snap = useSnapshot(state);
  const inc = () => ++state.count2;
  ...
}

// 리렌더링이 최적화된다.
```

## 접근 방식의 장단점

언제 써야하고, 언제 쓰지 말아야 하는가?

멘탈 모델 측면에서, Valtio는 불변 갱신, 변경 가능 갱신이 존재한다. 멘탈 모델 전환을 쉽게 할 수 있게 Valtio의 상태와 리액트의 상태를 명확히 분리하는 것이 좋다. 이 경우 Valtio 사용 여지가 생긴다. 그렇지 않으면 불변 갱신을 계속 사용해도 좋다.

```tsx
// valtio.
const Component = ({ showText }) => {
  const snap = useSnapshot(state);
  return (
    <>
      {snap.count} {showText ? snap.text : ''}
    </>
  );
};

// zustand. 코드가 길어졌고 훅이 많아졌다.
const Component = ({ showText }) => {
  const count = useStore((state) => state.count);
  const text = useStore((state = showText ? state.text : ''));
  return (
    <>
      {count} {text}
    </>
  );
};
```

프록시 기반 렌더링 최적화는 앱 코드를 간단하게 해주고, 훅을 줄여줄 수 있지만 예측 가능성이 떨어진다는 단점이 존재한다. 렌더링 최적화를 내부에서 처리해 동작 디버깅이 어려울 수 있다.

그러므로 요구사항에 따라 적절히 선택할 수 있어야 한다.
