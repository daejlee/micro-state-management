# 9 - 사용 사례 시나리오 3: Valtio

- 변경 가능한 갱신 모델, Zustand와 같이 모듈 상태 용도로 사용
- React는 불변성을 기준으로 변경 감지를 하기 때문에, Proxy 자체를 React에 그대로 주면 감지 못함
    - Valtio는 Proxy를 불변 객체로 복사(스냅숏)
- Proxy를 활용한 자동 리렌더링 최적화 - 상태 사용 추적
    - 선택자 필요 없음

# Valtio 살펴보기

- setState를 사용해야 하는 이유는 불변성 때문이다
    
    ⇒ 불변성을 지키지 않아도 된다면? `state.count++`와 같이 수정이 가능
    
    - 그러나 이는 React에서 감지되지 않으며, Proxy를 활용하면 감지되게 만들 수 있다

```tsx
const state = { count: 0, text: 'hello' };

const proxyState = new Proxy(state, {
  set(target, prop, value) { // set은 객체의 값이 생신될 때 실행
    target[prop] = value;
    console.log(prop);
  }
});

proxyState.count = 10;  // console: count
proxyState.text = 'world';  // console: text
```

# Snapshot

> Proxy를 사용하여 변경 가능한 객체로부터 생성한 불변 객체
> 

```tsx
import { proxy, snapshot } from "valtio";

const state = proxy({ count: 0 });

const snap1 = snapshot(state);
```

- `state`는 Proxy로 감싼 변경 가능한 객체
- `snap1`은 변경 불가능한 객체
    - Object.freeze로 읽기 전용 객체로 변환시킴 (추가, 삭제, 수정 불가)

```tsx
const snap2 = snapshot(state);
console.log(snap1 === snap2); // true

++state.count;

const snap3 = snapshot(state);
console.log(snap2 === snap3); // false
```

- 속성이 변경될 때만 새 스냅숏 생성 → 메모리 사용량 최적화
    - `snap1`과 `snap2`는 상태가 변경되지 않았기 때문에 같은 스냅숏 객체를 가리킴
    - `++state.count`로 상태가 변경되었기 때문에, 새로 생성된 `snap3`는 이전 스냅숏과 다름
- 중첩된 객체 또한 변경되지 않은 객체의 경우 같은 참조를 가짐
- 가장 최근 스냅숏 1개만을 캐싱 (최근 스냅숏 한 개와만 비교해서 같으면 재사용, 다르면 새로 생성)

# 리렌더링 최적화

```tsx
const Counter1 = () => {
  const snap = useSnapshot(state);
  const inc = () => ++state.count1;
  return (
    <>
      {snap.count1} <button onClick={inc}>+1</button>
    </>
  );
};
```

`snap.count1`와 같이 접근 → `useSnapshot`에 의해 추적 정보로 감지 → 필요한 경우 리렌더링

- 추적 정보: 컴포넌트가 어떤 속성에 접근했는지

```tsx
const Counter2 = () => {
  const snap = useSnapshot(state);
  const inc = () => ++state.count2;
  return (
    <>
      {snap.count2} <button onClick={inc}>+1</button>
    </>
  );
};

const App = () => (
  <>
    <Counter1 />
    <Counter2 />
  </>
);
```

추적 정보를 기억하고 있기 때문에 `Counter1`의 버튼을 클릭하면 `Counter1`는 리렌더링 되고, `Counter2`는 리렌더링 되지 않는다

```tsx
const TodoItem = ({ id, title, done }: {
  id: string;
  title: string;
  done: boolean;
}) => (
  <div>
    <input type="checkbox" checked={done} onChange={() => toggleTodo(id)} />
    <span style={{ textDecoration: done ? "line-through" : "none" }}>{title}</span>
    <button onClick={() => removeTodo(id)}>Delete</button>
  </div>
);

const MemoedTodoItem = memo(TodoItem);

const TodoList = () => {
  const { todos } = useSnapshot(state);
  return (
    <>
      {todos.map(({ id, title, done }) => (
        <MemoedTodoItem key={id} id={id} title={title} done={done} />
      ))}
    </>
  );
};
```

메모된 컴포넌트에 객체 전달 시 접근을 생략 (상태 사용 추적 → 속성 접근 감지)

⇒ 속성을 따로 받음

```tsx
const TodoItem = ({ id }: { id: string }) => {
  const todoState = state.todos.find((todo) => todo.id === id);
  if (!todoState) throw new Error("invalid todo id");

  const snap = useSnapshot(todoState);
  const { title, done } = snap;

  return (
    <div>
      <input type="checkbox" checked={done} onChange={() => toggleTodo(id)} />
      <span style={{ textDecoration: done ? "line-through" : "none" }}>
        {title}
      </span>
      <button onClick={() => removeTodo(id)}>Delete</button>
    </div>
  );
};
```

`id`로 `state`를 찾아 `snap`에서 속성을 가져오는 방식으로 리렌더링 개선이 가능

```tsx
const TodoList = () => {
  const { todos } = useSnapshot(state);
  const todoIds = todos.map((todo) => todo.id);
  return (
    <div>
      {todoIds.map((todoId) => (
        <MemoedTodoItem key={todoId} id={todoId} />
      ))}
    </div>
  );
};
```

`TodoList`가 `ids`만 보내주기 때문에 `id`가 변경되지 않는 이상 `TodoList`는 리렌더링 되지 않는다

# 주의점과 장단점

⚠️

- 변경 가능한 모델과 불변 모델, 두 가지가 있지만 React는 불변 상태를 중심으로 하므로 혼동하지 않아야 함
    - Valtio 상태와 React 상태를 명확히 분리하여 사용하는 방법이 있다

👍

- 네이티브 자바스크립트 함수를 쓸 수 있다 (splice, slice, …)
- 중첩된 객체의 값을 짧은 코드로 변경 가능하다

👎

- 떨어지는 예측 가능성
- 렌더링 최적화를 내부적으로 처리하여 디버깅이 힘듬