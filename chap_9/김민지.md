# 09. 사용 사례 시나리오 3: Valtio

> ## Valtio

### 다른 라이브러리와 다르게 **변경 가능한 갱신 모델**을 사용한다.

- 다른 라이브러리 (불변 갱신 규칙)

```javascript
const store = create(() => {count: 0, text: ''})
// 상태를 바꾸고 싶을 때
store.setState((prev) => {
  ...prev, count: prev.count + 1
})
```

- Valtio의 변경 갱신 모델

```javascript
const store = create(() => {count: 0, text: ''})
++store.count
```

### 프락시를 활용해 리렌더링 최적화를 한다.

- 프락시는 트굿한 객체로서 객체 연산을 감지하기 위한 핸들러를 만드는 데 활용할 수 있다.
- 다음은 객체 변경을 감지하는 set 핸들러 예시이다.

```javascript
const proxyObject = new Proxy(
  {
    count: 0,
    text: "",
  },
  {
    set: (target, prop, value) => {
      console.log("start setting", prop);
      target[prop] = value;
      console.log("end setting", prop);
    },
  }
);
```

### 스냅숏 :: 변경 가능한 객체에서 불변 객체 만들기

```javascript
const state = proxy({ count: 0 });

const snap1 = snapshot(state);

++state.count;

const snap2 = snapshot(state);
```

- 이때의 snap은 불변하고, snap1은 {count: 0}, snap2: {count1} 을 가진다.
- state자체는 속성이 변해도 이전과 동일한 참조를 가지고, snap2는 snap1과 다른 새로운 참조를 가진다.
- 스냅숏 생성을 자동으로 최적화 한다. (= 속성이 변경될 때만 새 스냅숏을 생성한다.)

  ```javascript
  const state = proxy({
    obj1: { c: 0 },
    obj2: { c: 0 },
  });

  const snap1 = snapshot(state);

  ++state1.obj1.c;

  const snap2 = snapshot(state);
  ```

  - snap1 = {obj1: {c: 0}, obj2: {c: 1}}
  - snap2 = {obj1: {c: 1}, obj2: {c: 2}}
  - 이때, snap1 !== snap2, snap1.obj1 !== snap.obj1 이다.
  - 그러나 obj2에 대해서는 변한 게 없으므로 snap1.obj2 === snap2.obj2 이다.
  - 결국 ㄱ필요한 경우메ㅏㄴ 스냅숏을 생성해서 메모리 사용량을 최적화 한다.

### useSnapshot을 통해 필요한 경우에만 리렌더링 하기.

- snap은 불변 객체이다. (객체 속성이 변해도 이전의 snap자체는 안변함)
- useSnapshot은 해당 스냅에서 return에 사용되는 부분이 변경되었을 때만 자동으로 리렌더링한다.

  ```javascript
  const snap = useSnapshot(state);

  return <div>{snap.count}</div>;
  ```

  - 이 경우 snap의 count값이 바뀌었을 때만 리렌더링 한다.

### Valtio의 장단점

[장점]

- 네이티브 자바스크립트 함수를 사용할 수 있다.

```javascript
// 불변 갱신 모델
[...array.slice(0, index), ...array.slice(index + 1)];

// Valtio
array.splice(index, 1);
```
  - 코드를 줄일 수 있다는 장점도 있다.

- 상태에서 원하는 속성값을 뽑아쓰기 편하다.
  -  선택자 모델은 뽑아쓸 값을 선택자로 계속 추출해야 한다. (조건이 많아질 수록 훅이 더 많이 필요하다.)

[단점]

- 예측 가능성이 떨어진다. (=> 디버깅이 어려워진다.)