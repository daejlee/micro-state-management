# 사용 사례 9장

아래 내용은 Valtino 는 Jotai 와 다르게 변경 가능한 개신 모델을 기반으로 하는 또 다른 전역 상태 관리 라이브러리이다. Zustand 와 같이 모듈 상태용으로 사용됩니다.
리액트와 통합을 위해 Valtio 는 프락시를 통해 변경 불가능한 스냅숏을 가져옵니다.

Valtio의 자동 렌더링 최적화는 상태 사용추적 기법을 기반으로 합니다. 상태 사용추적을 이용하면 상태의 어느 부분이 사용되는지 감지할 수 있으며, 사용된 부부닝 변경될 경우에만 컴포넌트를 리렌더링 할 수 있게됩니다.

## 기본 사용 예시

```js
import { proxy, useSnapshot } from "valtio";

// 1) 프록시 상태 생성 (mutable처럼 대입으로 변경)
const state = proxy({
	count: 0,
	text: "hello",
});

// 2) 컴포넌트에서 스냅샷 사용 (읽은 경로만 추적)
export function Counter() {
	const snap = useSnapshot(state);
	return <button onClick={() => (state.count += 1)}>{snap.count} </button>;
}
```

> Valtio에서는 `state.count += 1`처럼 그냥 대입하세요.

---

## 프록시를 활용한 변경 감지 및 불변 상태 생성하기

Valtio는 프록시로 만든 원본 상태(mutable처럼 보이는 프록시)와, 렌더 단계에서 읽는 스냅샷(읽기 전용, 불변)을 분리합니다.

```js
import { proxy, useSnapshot } from "valtio";

const store = proxy({ a: 1, b: { c: 2 } });

export function View() {
	const snap = useSnapshot(store); // 스냅샷은 불변(읽기 전용)
	// snap.a = 2; // 금지: 스냅샷 수정은 런타임 에러 가능
	// store.a = 2; //  수정은 항상 프록시에
	return (
		<p>
			{snap.a} / {snap.b.c}
		</p>
	);
}

function mutate() {
	store.a += 1; // set handler로 변경 감지
	store.b.c = 999; // 중첩도 동일
}
```

- **get/set 트랩**: 프록시가 `get`/`set`을 가로채 **읽힌 경로**와 **변경된 경로**를 기록합니다.
- **스냅샷**: 렌더에서 사용하는 값은 **불변 스냅샷**으로 제공되어, React의 순수 렌더 가정과 잘 맞습니다.
- **수정 위치**: 업데이트는 항상 `store`(프록시)에 수행하고, 렌더는 `snap`만 읽습니다.

## 프록시를 활용한 리렌더링 최적화

Valtio는 리렌더링을 최적화 하고 변경을 감지하기 위ㅐ서 프락시를 사용합니다. 이는 6장 전역상태 라이브러링서 속성 접근 ㅏㅁ지 절에서 배운 리렌더링 최적화 패턴입니다.

Valtio의 useSnapshot 의 구현은 snapshot 함수와 이를 감싸는 다른 프락시를 기반으로 합니다. 이 snapshot 프락시는 proxy 함수에서 사용되는 프락시와 다른 목적이 있습니다. snapshot 프락시는 느냅숍 객체의 접근 속성을 감지하는데 사용됩니다. snapshot 프락시를 통해 렌더링 최적화를 확인해봅면 도비니다.

```js
const app = proxy({
	left: { value: 1 },
	right: { value: 10 },
});

export function LeftPanel() {
	const s = useSnapshot(app);
	return <div>Left: {s.left.value}</div>; // ← 이 경로만 반응
}

export function RightPanel() {
	const s = useSnapshot(app);
	return <div>Right: {s.right.value}</div>; // ← 이 경로만 반응
}

function incLeft() {
	app.left.value += 1;
}
function incRight() {
	app.right.value += 1;
}
```

- `incLeft()`는 **LeftPanel만** 리렌더, `incRight()`는 **RightPanel만** 리렌더 됩니다.
- 리스트/그리드에서는 **아이템 단위 컴포넌트**가 자신이 읽는 아이템만 접근하도록 설계하면, 큰 데이터셋에서도 효율적입니다.

> 상위 객체를 통째로 구조분해해서 읽으면 추적 범위가 넓어질 수 있습니다. 정말 필요한 속성까지 내려가서 읽어야 효과가 큽니다.

## Valtio, 언제 쓰고 언제 피할까?

Valtio는 두가지 상태 모델이 있습니다. 하나는 불변 갱신이고 하나는 변경 가능한 갱신입니다. 자바스크립트 자체는 변경 가능한 갱신을 허용하지만 리액트는 불변 상태를 중심으로 만들어졌습니다. 따라서 두 모델을 같이 하는 경우 혼동하지 않도록 주의해야합니다. 괜찮은 해결책은 멘탈 모델 전환을 쉽게 할 수 있도록 Valtio 와 리액트 상태를 명확하게 분리합는것입니다. 전역/모듈 상태처럼 여러 컴포넌트가 공유하는 값은 Valtio(프록시)로 관리하고, 컴포넌트 로컬 상태는 React의 useState/useReducer로 불변 갱신을 고수합니다. 이렇게 분리하면, Valtio 를 활용할 여지가 생기게 됩니다. 그렇지 않은 경우에는 불변 갱신을 계속 이용하는 것이 좋을 수도 있ㅅ브니다.

변경 가능한 갱신의 가장 큰 장점은 네이티브 자바스크립트 함수를 사용할 수 있다는 것입니다.

```js
//변경 가능한 갱신 (Valtio) — 네이티브 문법 그대로
import { proxy, useSnapshot } from "valtio";

// 대입/푸시 등 네이티브 갱신을 그대로 사용 가능
export const store = proxy({
	count: 0,
	todos: [{ id: 1, text: "하나", done: false }],
});

// 읽기: 스냅샷(불변) — 렌더에서만 사용
export function Counter() {
	const snap = useSnapshot(store); // 읽은 경로만 추적되어 그 경로 변경 시에만
	return <button onClick={() => (store.count += 1)}>{snap.count}</button>;
}
```

업데이트는 항상 프록시(store)에 대입/푸시로 수행하고, 렌더는 스냅샷(snap)만 읽습니다. 스냅샷은 읽기 전용

```js
//불변 갱신 (React 로컬 상태) — 컴포넌트 내부에서는 복사로 안전하게
import React from "react";

export function LocalForm() {
	const [form, setForm] = React.useState({ title: "", tags: ["web"] });

	// ✅ 불변 갱신: 객체/배열을 복사해서 새 참조로 교체
	const onChangeTitle = (e) =>
		setForm((prev) => ({ ...prev, title: e.target.value }));
	const addTag = (t) =>
		setForm((prev) => ({ ...prev, tags: [...prev.tags, t] }));

	return (
		<button onClick={() => addTag("react")}>
			{JSON.stringify(form, null, 2)}
		</button>
	);
}
```

로컬 상태는 React가 불변 참조 변경을 전제로 동작하므로 불변성을 유지하도록 해야함

```js
//섞어서 쓸 때의 안전 규칙 (Proxy ↔ Snapshot)
// 잘못된 예 — 스냅샷은 읽기 전용
function Wrong() {
	const snap = useSnapshot(store);
	return <button onClick={() => (snap.count += 1)}>{snap.count}</button>;
}

// 올바른 예 — 수정은 프록시에, 읽기는 스냅샷으로
function Right() {
	const snap = useSnapshot(store);

	return <button onClick={() => (store.count += 1)}>{snap.count} </button>;
}
```

수정은 항상 프록시(store)에: store.x = ..., store.todos.push(...)

렌더는 스냅샷(snap)으로만 읽기: snap.x, snap.todos[i].text

상위 객체를 통째로 구조분해하면 추적 범위가 넓어질 수 있으니, 필요한 속성까지 내려가서 읽기가 성능에 유리
