# 9. Valtio

Zustand는 `useStore` 훅을 사용하여 상태를 구독하고, 필요한 상태만 선택적으로 가져올 수 있다.
그러나 Valtio는 Proxy를 사용하여 상태를 관리하며, 상태 변경 시 자동으로 리렌더링을 수행한다. Valtio는 상태를 더 쉽게 관리할 수 있도록 도와준다.

## Proxy 란?

기본적으로 Javascript에는 Proxy API를 제공한다.
Proxy는 객체의 기본 동작을 가로채고, 사용자 정의 동작을 수행할 수 있도록 해준다. 이를 통해 객체의 속성 접근, 수정, 삭제 등의 작업을 가로채어 추가적인 로직을 실행할 수 있다.

```js
const target = {
  message: "Hello, world!",
};

const handler = {
  get: function (target, prop, receiver) {
    console.log(`Getting ${prop}`);
    return target[prop];
  },
  set: function (target, prop, value, receiver) {
    console.log(`Setting ${prop} to ${value}`);
    target[prop] = value;
  },
};

const proxy = new Proxy(target, handler);

console.log(proxy.message); // proxy 객체의 읽기를 사용했으므로 핸들러의 get 메서드가 호출된다.
proxy.message = "Hello, Proxy!"; // proxy 객체의 쓰기를 사용했으므로 핸들러의 set 메서드가 호출된다.
```

Valtio에서는 이러한 Proxy의 개념을 활용하여 상태를 관리한다.

## Valtio의 proxy

```js
import { proxy } from "valtio";

const state = proxy({
  message: "Hello, world!",
});
```

## Valtio의 snapshot

또한 이렇게 생성된 상태를 snapshot이라는 개념을 통해 읽고, state는 바로 할당할 수 있다.

```js
import { useEffect } from "react";
import { useSnapshot } from "valtio";

const App = () => {
  const snap = useSnapshot(state);

  return (
    <div>
      <h1>{snap.message}</h1>
      <button onClick={() => (state.message = "Hello, Valtio!")}>
        Change Message
      </button>
    </div>
  );
};
```

### snapchot을 따로 쓰는 이유

여기서 이러한 궁금점이 생길 수 있다.

> 왜 get할때는 snapshot을 사용하고, set할 때는 state를 직접 수정하는 걸까?

Valtio가 proxy, snapshot을 사용하는 이유는 상태의 변경을 감지하기 위함이다. state.count++와 같이 상태를 변경하는 코드가 실행될 때, 프록시는 이 변경을 가로채서 Valtio에게 "상태가 바뀌었다"고 알려준다.(바닐라 JS의 Proxy handler에 set 이 있음) 이 알림을 받은 useSnapshot은 컴포넌트를 리렌더링하는 원리이다.

만약 프록시 객체의 값을 직접 get 하는 기능이 있다면, Valtio는 언제 값이 "읽혔는지" 추적하기 어려워지고, 최적화된 렌더링을 구현하기 복잡해진다. 따라서 snapshot이라는 명시적인 방법을 통해 상태를 읽도록 설계된 것이다.

### 불변 상태

```js
const state = proxy({
  obj1: { c: 0 },
  obj2: { c: 0 },
});

const snapshot1 = snapshot(state);

++state.obj1.c;

const snapshot2 = snapshot(state);
```

여기서 snapshot1과 snapshot2는 서로 다른 스냅샷을 참조하게 된다. 즉, snapshot1은 state의 초기 상태를, snapshot2는 state의 변경된 상태를 반영하게 된다. 만약 중간에 `++state.obj1.c`이 없었더라면, snapshot1과 snapshot2는 동일한 상태를 참조하게 되었을 것이다. 이러한 방식으로 Valtio는 상태의 불변성을 유지하면서도 효율적인 렌더링을 가능하게 한다.

### useSnapshot 내부 동작

useSnapshot은 내부적으로 snapshot을 생성하고, 상태가 변경될 때마다 새로운 스냅샷을 반환한다. [공식코드](https://github.com/pmndrs/valtio/blob/main/src/react.ts#L121)를 의사코드로 표현하면 다음과 같다.

```js
// Valtio 라이브러리 내부 (단순화된 개념)

// 1. 컴포넌트별로 어떤 상태를 읽었는지 기록하는 저장소
const componentSubscriptions = new WeakMap();

// 2. Proxy를 통해 상태 읽기를 추적하는 함수
function trackAccess(proxyState, component) {
  // 현재 컴포넌트가 어떤 속성들에 접근했는지 기록할 Set을 준비
  if (!componentSubscriptions.has(component)) {
    componentSubscriptions.set(component, new Set());
  }
  const accessedProperties = componentSubscriptions.get(component);

  // Proxy를 생성하여, 상태 객체의 모든 속성 접근을 감시
  return new Proxy(proxyState, {
    get(target, prop) {
      // 컴포넌트가 어떤 속성을 읽었는지 기록 ('구독' 행위)
      accessedProperties.add(prop);
      // 원래 값을 반환
      return target[prop];
    },
  });
}

// 3. useSnapshot 훅의 의사코드
function useSnapshot(proxyState) {
  // React의 useSyncExternalStore를 사용해 외부 상태(Valtio)와 컴포넌트를 연결
  const snapshot = useSyncExternalStore(
    // (1) 구독 로직: 상태가 바뀌면 이 함수를 실행해줘!
    (onStoreChange) => {
      // Valtio 상태가 변경될 때마다 onStoreChange 콜백을 호출하는 구독 함수를 반환
      // 이 함수는 컴포넌트가 unmount될 때 호출되어 구독을 취소함
      return subscribe(proxyState, onStoreChange);
    },
    // (2) 상태 가져오기 로직: 현재 스냅샷을 반환해줘!
    () => getSnapshot(proxyState)
  );

  // 현재 컴포넌트의 'this' 같은 식별자를 얻어옴 (실제로는 React가 내부적으로 처리)
  const currentComponent = getCurrentlyRenderingComponent();

  // 프록시를 통해 컴포넌트가 어떤 값을 읽는지 추적
  const trackedSnapshot = trackAccess(snapshot, currentComponent);

  return trackedSnapshot;
}
```

## 응용하기

```js
const TodoList = () => {
  const { todos } = useSnapshot(state);

  return (
    <div>
      {todos.map((todo) => (
        <TodoItem
          key={todo.id}
          id={todo.id}
          title={todo.text}
          done={todo.done}
        />
      ))}
    </div>
  );
};

const TodoItem = ({ id, title, done }) => {
  return (
    <div>
      <input type="checkbox" checked={done} onChange={() => toggleTodo(id)} />
      <span>{title}</span>
    </div>
  );
};
```

위 방법은 우리가 흔히 jotai, zustand에서 쓰는 방식으로 state를 가져와서 그대로 배열을 순회하여 하위 컴포넌트로 뿌려주는 방식이다.
위 방식은 todos에서 한 아이템의 done, text가 변경되면 리렌더링이 발생한다.

```js
const TodoList = () => {
  const { todos } = useSnapshot(state);
  const todoIds = todos.map((todo) => todo.id);

  return (
    <div>
      {todoIds.map((todoId) => (
        <TodoItem key={todoId} id={todoId} />
      ))}
    </div>
  );
};

const TodoItem = ({ id }) => {
  const todoState = state.todos.find((todo) => todo.id === id);
  const { text, done } = useSnapshot(todoState);
  return (
    <div>
      <input type="checkbox" checked={done} onChange={() => toggleTodo(id)} />
      <span>{text}</span>
    </div>
  );
};
```

그러나 두번째 방식은 todos의 done, text가 변경되면 TodoList에서 리렌더링이 발생하지 않는다. 대신 TodoItem에서만 리렌더링이 발생한다. 이러한 차이로 인해 두번째 방식이 더 나은 성능을 발휘할 수 있다.
