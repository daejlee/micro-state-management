# 9. Valtio

- 변경 가능한 갱신 모델 기반 상태 관리 라이브러리

- 모듈 상태용으로 사용되며, 리액트와의 통합을 위해 proxy를 사용해 변경 불가능한 snapshot을 가져온다.

- API는 자바스크립트만으로 이뤄져 있어 모든 작업이 내부에서 처리된다.

- proxy를 활용해 자동으로 리렌더링을 최적화하며, 리렌더링을 제어하기 위해 선택자가 아닌 상태 사용 추적이라는 기버을 기반으로 한다.
  - 상태의 어느 부분이 사용되는지 감지할 수 있으며, 사용된 부분이 변경될 경우에만 컴포넌트를 리렌더링되게 할 수 있다.

## Proxy

보통 모듈 상태 관리 라이브러리에서의 불변 갱신 규칙은 다음과 같다.

```ts

const store = create(()=>{
  count: 0,
  text: "hello",
});

store.setState((prev) => ({
  count: prev.count + 1,
}));

moduleState = Object.assign({}, moduleState, {
  count: moduleState.count + 1
});
```

위와 같이 setState를 사용하여 객체를 불변으로 갱신한다.

불변 갱신 규칙을 따르지 않게 `++moduleState.count;` 처럼 사용한다고 하면, 코드가 간략해진다.

```ts
const proxyObject = new Proxy(
  {
    count: 0,
    text: "count",
  },
  {
    set: (target, prop, value) => {
      target[prop] = value;
    },
  }
);
```

Proxy를 사용하면 위와 같은 코드도 감지하여 리액트에서 동작시킬 수 있다.

**`Proxy`**: 자바스크립트의 특수한 객체로서 객체 연산을 감지하기 위한 핸들러를 만드는 데 활용할 수 있다.

## proxy(), snapshot()

valtio는 proxy를 사용해 변경 가능한 객체에서 변경 불가능한 객체를 생성하고, 이 불변 객체를 snapshot이라고 한다.

## 리렌더링 최적화

```ts
import { proxy, useSnapshot } from "valtio";

const state = proxy({
  count1: 0,
  count2: 0,
});

const Counter1 = () => {
  const snap = useSnapshot(state);
  const inc = () => ++state.count1;
  return (
    <>
      {snap.count1} <button onClick={inc}>+1</button>
    </>
  );
};

const Counter2 = () => {
  const snap = useSnapshot(state);
  const inc = () => ++state.count2;
  return (
    <>
      {snap.count2} <button onClick={inc}>+1</button>
    </>
  );
};
```

Counter1 컴포넌트는 snapshot 객체의 count1 속성에 접근하고 Counter2 컴포넌트는 count2 속성에 접근한다.

각 컴포넌트의 useSnapshot 훅은 추적 정보(컴포넌트가 어떤 속성에 접근했는지)를 기억하고 알아낼 수 있다.

그래서 count1이 변경이 되어도 count2는 변경이 되지 않았기에, count2 속성에 접근하고 있는 Counter2 컴포넌트는 리렌더링되지 않는다.

```ts
const MemoedTodoItem = memo(TodoItem);

const TodoList = () => {
  const { todos } = useSnapshot(state);
  return (
    <div>
      {todos.map((todo) => (
        <MemoedTodoItem key={todo.id} id={todo.id} title={todo.title} done={todo.done} />
      ))}
    </div>
  );
};
```

다만, 이런 todo같은 배열을 사용하면, 배열에 있는 모든 속성에 접근하기에 일부만 변경 되어도 리렌더링을 감지한다.  
그래서 TodoItem만이 아니라, TodoList 전체가 리렌더링된다.

```ts
const TodoItem = ({ id }: { id: string }) => {
  const todoState = state.todos.find((todo) => todo.id === id);
  ...
};

const MemoedTodoItem = memo(TodoItem);

const TodoList = () => {
  const { todos } = useSnapshot(state);
  const todoIds = todos.map((todo) => todo.id);
  return (
    <div>
      {todoIds.map((todoId) => (
        <MemoedTodoItem key={todoId} id={todoId} />
      ))}
    </div>
  );
};
```

이렇게 TodoItem에 id만 넘겨주고, TodoItem에서는 id를 가지고 상태에서 찾는 방식을 사용하면, TodoList 컴포넌트는 배열에서 id의 순서가 변경되거나 추가 및 제거가되는 경우에만 리렌더링된다.

하지만 이렇게 한다고 전체 성능이 개선되는 것은 아니기에 어떤 접근방식을 선택해야하는지는 애플리케이션에 따라 다르다.

## 장단점

**장점**

- 네이티브 자바스크립트 함수를 사용할 수 있다.

- proxy기반 렌더링 최적화를 사용해 코드량을 줄이는 데 도움이 된다.

**단점**

- proxy기반 렌더링 최적화는 예측 가능성이 떨어진다.

- proxy는 렌더링 최적화를 내부적으로 처리하기 때문에 동작을 디버깅하기가 어려울 수 있다.
