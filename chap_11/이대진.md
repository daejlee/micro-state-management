# 11. 세 가지 전역 상태 라이브러리의 유사점과 차이점

Zustand는 사용법과 스토어 모델이라는 점에서 리덕스와 유사하지만 리듀서 기반이 아니다.

Jotai는 API 측면에서 리코일과 비슷하지만 셀렉터 기반이 아니고 렌더링 최적화를 위한 최소한의 API를 제공하는 것이 목표다.

Valtio는 변경 가능한 갱신 모델이라는 점에서 MobX와 유사하지만 렌더링 최적화가 매우 다르다.

세 라이브러리 모두 마이크로 상태 관리에 적합한 기본 기능을 제공하지만, 코딩 스타일과 렌더링 최적화에 대한 접근 방식이 다르다.

# Zustand와 Redux의 차이

둘 다 단방향 데이터 흐름에 기반한다. 상태 갱신 명령을 나타내는 action을 실행하고 전파된다. 디스패치와 전파를 분리하는 것은 데이터의 흐름을 단순화하고, 전체 시스템을 더 예측 가능하게 만든다.

<aside>

    “디스패치와 전파를 분리한다?”가 무슨 말인지.

    상태 변경을 발생시키는 행위(디스패치)와 그 변경된 상태가 UI 또는 다른 로직에 영향을 미치도록 전달되는 과정(전파)를 명확히 나누는 것

    - Dispatch (디스패치): 상태를 변경하는 요청.
      일반적으로 `action`을 발생시켜 상태를 갱신
    - Propagation (전파): 변경된 상태가 필요한 컴포넌트나 구독자에게 전달되는 과정.
    보통 `useSelector`, `subscribe`, 혹은 상태 훅(`useStore`) 등으로 상태를 받아 UI를 갱신

</aside>

### 주요 차이점

- 디렉터리 구조
  - Redux는 feature 디렉터리 구조를 제안한다. 이는 대규모 앱에 유용한 패턴이다.
  - Zustand는 구조에 대한 의견을 제시하지 않는다.

```jsx
src/
├── app/
│   └── store.js
├── features/
│   ├── counter/
│   │   ├── Counter.jsx       // 컴포넌트
│   │   ├── counterSlice.js   // Redux slice
│   │   └── counterAPI.js     // API 호출 관련 파일
│   ├── user/
│   │   ├── UserProfile.jsx
│   │   ├── userSlice.js
│   │   └── userAPI.js
// FSD와 개념적으로 비슷할 수 있겠다고 생각했어요 (목적이 비슷하지 않나)
```

- Immer
  - 최신 Redux는 기본적으로 Immer를 사용
  - Zustand는 Immer 사용이 선택적

```jsx
// 리덕스
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      // 직접 수정 가능
      state.value += 1;
    },
  },
});
// 쭈스탄트
import { immer } from 'zustand/middleware/immer';
const useCounterStore = create(
  immer((set) => ({
    value: 0,
    increment: () =>
      set((state) => {
        state.value += 1; // Immer 덕분에 직접 변경 OK
      }),
  }))
);
```

- 상태 전파
  - Redux는 컨텍스트를 사용 - 런타임에 스토어를 주입할 수 있어 일부 케이스에선 더 효과적.
  - Zustand는 모듈 임포트를 사용 - 컨텍스트 사용을 선택적으로 지원
- 데이터 흐름
  - Redux는 Action → Dispatch → Reducer의 흐름을 강제함 - 유지보수성, 확장성에 도움
  - Zustand는 데이터 흐름에 대한 의견을 제시하지 않음 - 함수를 직접 호출하기 때문
    개발자가 처리해야 함.

<aside>

    특수한 의도를 가지고 작성했거나, 어지간히 이상한 코드가 아닌 이상 Zustand의 단방향 모델을 따르지 않는 경우는 없을 것 같다. 그렇지 않다면 관리를 어떻게 하려고?

</aside>

소규모 앱의 경우 Zustand로 보일러플레이터 코드 없이 빠르게 구현하는 게 좋을 것 같고,
중-대규모의 앱에선 Redux의 사용도 고려해볼만 한 것 같네용

# Jotai와 Recoil을 사용하는 시점

### 주요 차이점

- key 문자열의 차이
  - Recoil은 atom에 key가 필요하다. `({ key: ‘textState’, default: ‘’ })`
  - Jotai는 atom에 key가 필요없다. (이전 챕터에서 고유 키 생성 과정도 밟아본 바 있다)
    `atom(’’)`
  - 그럼 Jotai가 무조건 우월한가? 그건 아닙니다.
  - Jotai는 WeakMap을 활용해 아톰 객체 참조에 의존하고, Recoil은 객체 참조에 의존하지 않는 key 문자열을 기반으로 한다. key 방식의 장점은 직렬화가 가능하다는 것.
    이는 직렬화가 필요한 지속성(persistent, 로컬스토리지 세션스토리지)을 쉽게 구현할 수 있다는 것을 의미한다.
    Jotai에선 이걸 달성하기 위해 다른 기법이 필요하다.
- Jotai의 atom 함수는 Recoil의 atom, selector 둘을 대체하는데, 트레이드오프가 존재한다.
  - atom 함수는 모든 것을 표현하는 것이 불가능하다. 이 말은,
  - Recoil에선 atom과 selector가 분리되어 있어 복잡한 로직도 구조적으로 깔끔히 표현할 수 있다.
  - 하지만 Jotai에서는 atom으로만 모든 것을 표현해야 하기 때문에 다른 헬퍼 함수들이 필요한 경우들이 존재한다.

```jsx
// Jotai
const countAtom = atom(0); // 기본 상태
const doubleCountAtom = atom((get) => get(countAtom) * 2); // 파생 상태
const asyncAtom = atom(async (get) => { // 비동기 상태
  const data = await fetch(...);
  return data;
});
```

```jsx
// Recoil
export const countState = atom({
  // 기본 상태
  key: 'countState',
  default: 0,
});

export const doubleCountSelector = selector({
  // 파생 상태
  key: 'doubleCountSelector',
  get: ({ get }) => {
    const count = get(countState);
    return count * 2;
  },
});

export const asyncDataSelector = selector({
  // 비동기 상태
  key: 'asyncDataSelector',
  get: async () => {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    return data;
  },
});
```

- 마지막으로 Jotai에선 Provider 컴포넌트를 생략할 수 있다. 사소한 이점인듯.

# Valtio와 MobX 사용하기

Valtio와 MobX 둘 다 변경 가능한 상태를 기반으로 한다. 다만 렌더링 최적화 방식에 차이가 존재하는데, Valtio는 훅을 사용하고 Mobx는 HoC를 사용한다.

### 주요 차이점

- 갱신 방식 - 스타일적 차이임.
  - MobX는 클래스 기반
  - Valtio는 객체 기반
- 렌더링 최적화 방식
  - MobX는 옵저버 방식 - 더 예측 가능성이 높음
  - Valtio는 훅 방식 - 동시성 렌더링에 더 친화적

```jsx
// Mobx에서 렌더링 중 부작용을 일으킬 수 있는 경우
class Store {
  count = 0;
  constructor() {
    makeAutoObservable(this);
  }
  increment() {
    this.count += 1;
  }
}
const store = new Store();
const Counter = observer(() => {
  // 렌더링 중 store.count에 접근하면 자동으로 구독됨 -> 렌더링 중 사이드 이펙트!!
  return <div>{store.count}</div>;
});

// Valtio
const state = proxy({ count: 0 });
const Counter = () => {
  const snap = useSnapshot(state); // 렌더링 전에 상태를 안전하게 "스냅샷"으로 캡처
  // 음.. 사이드 이펙트 예방에 더 친화적인 구조를 가지고 있다고 이해하면 될 것 같습니다.
  return <div>{snap.count}</div>;
};
```

# Zustand, Jotai, Valtio

지금까지 살펴본 바, 세 라이브러리의 공통 철학은 작은 API를 제공하는 것이다. 가능한 작은 API를 제공하고, 개발자의 필요에 따라 API를 조합할 수 있게 한다.

세 라이브러리의 차이점은,

## 상태가 어디에 위치하는가?

- 모듈 상태 - Zustand, Valtio
  - 리액트 외부에서 정의된 전역 상태
  - 상태가 모듈에 존재 → 어디서든 접근 가능
- 컴포넌트 상태 - Jotai
  - React 내부에서 정의된 상태 (`useState`, `useReducer` 등)
  - 컴포넌트 간 구분, 재사용에 유리

예시를 같이 보면 좋을 것 같아서 몇 가지 가져와봤습니닷

### 모듈 상태가 적합한 경우

- 로그인 사용자 정보, 테마, 다크모드 등 "앱 전체에서 공유되는 전역 상태”

```jsx
// valtio
const userStore = proxy({ user: null, isLoggedIn: false });
```

- React 외부에서 상태에 접근해야 할 때
  - WebSocket 수신 이벤트 → 상태 업데이트
  - setTimeout/setInterval 내부에서 상태 접근 등등..

```jsx
// zustand
import { getState } from './store';

socket.on('data', (data) => {
  const state = getState();
  state.updateData(data);
});
```

- SSR(서버사이드 렌더링) 없이 빠르게 동작해야 하는 상태
  - React가 아직 마운트되지 않은 상태에서도 접근 가능
  - 예: 비동기 초기화, 브라우저 storage 연동 등

### 컴포넌트 상태가 적합한 경우

솔직히.. 그 외의 경우는 모두 적합한 것 같습니다..

- 다수의 컴포넌트에서 **독립적으로** 사용되는 상태
  - 상태가 공유되지 않아야 함 (재사용되는 컴포넌트 내에서 각각 독립적이어야 함)
  - 예: 여러 개의 모달 각각의 open 상태, 개별 탭 상태 등

```jsx
// Jotai
const modalAtom = atom(false);
```

- 상태가 **React 생명주기와 함께 사라져야** 할 때
  - 예: 특정 컴포넌트가 사라지면 그 상태도 같이 제거되어야 할 때
  - 모듈 상태는 기본적으로 앱 전체에 살아 있어서 수동으로 reset해야 함
- **Suspense, startTransition** 등 React 동시성 기능과 잘 연동되어야 할 때
  - React의 최신 기능들과 일관되게 작동하도록 하려면 컴포넌트 상태 기반이 더 안전
  - 예: 서버 컴포넌트, 렌더링 중 로딩 상태 처리 등

### 혼합 사용의 케이스

검색 기능 + 입력 폼

```jsx
// 모듈 상태 (검색어), 검색어는 모듈 상태로 유지해서 여러 컴포넌트에서 사용
const searchState = proxy({ keyword: '' });
// 컴포넌트 상태 (폼 데이터), 입력 폼은 각 컴포넌트에서만 유효해야 하므로 컴포넌트 상태 사용
const formAtom = atom({ name: '', email: '' });
```

## 상태 갱신 스타일은 무엇인가?

### **Zustand: 불변 상태 모델 (Immutable State)**

- 상태 객체는 변경 불가능
- 상태를 업데이트할 때는 항상 **새로운 객체를 생성**해야 함
  예) `state = { count: state.count + 1 }`
- 객체 참조를 비교하여 변경 여부를 쉽게 감지 가능 → 효율적 성능 관리 가능
- React의 불변 상태 철학과 잘 맞아서 호환성 높음
- 결과적으로 라이브러리가 가볍고 간결

### **Valtio: 변경 가능한 상태 모델 (Mutable State)**

- 상태 객체를 직접 **수정(변경)** 가능
  예) `++state.count`
- JavaScript 객체의 본질적인 변경 가능성을 활용
- 특히 **중첩된 깊은 객체**를 다룰 때 편리함
- 내부적으로 변경 추적 메커니즘을 통해 React와 연동

<aside>

    개인적으로 불변 상태 모델이 더 나은 것 같습니다.

    변경 가능한 상태 모델도 사실 Jotai에 Immer 적용하면 Valtio에서 하듯이 객체를 직접 수정하는 것 처럼 사용이 가능하니까요, 거의 대체가 가능하지 않을까 싶습니다..

</aside>
