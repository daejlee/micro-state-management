# 11장. 세 가지 전역 상태 라이브러리의 유사점과 차이점


## Zustand와 Redux의 차이점

Zustand와 Redux는 모두 단방향의 데이터 흐름을 기반으로 한다.   
상태 갱신을 나타내는 action, 그리고 이를 통해 상태가 갱신된 후 새로운 상태가 필요한 곳으로 전파되는 형태다.

또한, React 생태계와 느슨한 결합을 가진다.  
Zustand와 Redux 모두 React 외부에서 Dispatch/SetState 및 subscribe가 가능하다.

하지만, 차이점도 있다.

우선, 업데이트 방식이 다르다.  
Redux는 dispatch({ type, payload }) 와 같이 리듀서라는 순수함수가 새 불변 상태를 반환한다.  
매우 엄격한 방법이고, 예측가능성이 높다.
하지만, Zustand는 set((s) => ({...})) 또는 set({ ... }) 을 통해 가변 / 불변 객체를 생성하는 것이 가능하다.

> 물론 불변 객체를 생성하는 것이 권장되는 것 같다.

그리고 선택적으로 리렌더링을 하는 방식이 다르다.

Redux는 useSelector 로 선택하고, 얕은 비교를 진행한다.  
스토어 레벨에서는 상태가 변경되었다는 정보만 알리고, 리렌더링에 대한 판단은 React-redux가 진행한다.  
반면, Zustand는 selector + equalityFunction 을 통해, 개별 조각만 구독하고, 비교가 가능하다.

```tsx
import { configureStore, createSlice, PayloadAction } from '@reduxjs/toolkit'

const counter = createSlice({
  name: 'counter',
  initialState: { count: 0 },
  reducers: {
    inc: (state) => { state.count += 1 },            
    add: (state, action: PayloadAction<number>) => { state.count += action.payload },
  },
})

export const { inc, add } = counter.actions

export const store = configureStore({
  reducer: { counter: counter.reducer },
})

// 아래와 같이 리액트 외부에서도 사용하는 것이 가능하다.
store.subscribe(() => {
  const state = store.getState()
  console.log(state)
})

store.dispatch(inc())
store.dispatch(add(5))

// 리액트에서 사용하는 경우도 있다. with React-redux
import { useSelector, useDispatch } from 'react-redux'
import { inc } from './store'

export default function Counter() {
  const dispatch = useDispatch()
  const count = useSelector((s: any) => s.counter.count) // 선택적 구독도 가능하다.
  return <button onClick={() => dispatch(inc())}>{count}</button>
}

```

Zustand 코드는 다들 너무 익숙할 것 같아 생략...

추가적으로, 책에 나온 두 라이브러리의 차이점이다.

디렉터리 구조.
Redux는 features 디렉터리 구조를 제시한다. 반면 Zustand는 어떤 구조도 제시하지 않는다.

상태전파.
Redux는 컨텍스트를, Zustand는 모듈 import를 사용한다.

## Jotai와 Recoil을 사용하는 시점

Jotai는 Recoil과 유사하다.

두 라이브러리 모두 상태 단위로 atom을 사용한다.  
하지만, Jotai의 경우, 개발자 입장에서 key 문자열을 생략할 수 있다는 점이 큰 장점인 것 같다.  
이는, WeakMap 기반의 Jotai와 달리, Recoil은 객체 참조에 의존하지 않는 key 를 기반으로 하기 때문이다. 

또한, Recoil의 경우 RecoilRoot를 적용해야 한다.  
Recoil의 경우, 전역 그래프로 atom/selector 간의 의존성을 관리하고, 이 그래프가 React의 생명주기와 맞물려야 한다.  
따라서, Context Provider 내 store 인스턴스를 초기화 하고, 모든 내부 훅이 이 컨텍스트 안에서 동작하도록 한다.  
하지만, Jotail의 경우 함수성 atom 객체이다. 전역에 기본적인 store가 하나 있는 구조라고 생각하면 편할 것 같다.

간단히 코드 구조를 비교해보면 다음과 같다.

```tsx
import { atom, useAtom } from 'jotai'

const countAtom = atom(0)

function Counter() {
  const [count, setCount] = useAtom(countAtom) // 그냥 작동함
  return <button onClick={() => setCount(c => c+1)}>{count}</button>
}

export default function App() {
  return <Counter /> // Provider 없어도 된다.
}

```

```tsx
import { atom, useRecoilState, RecoilRoot } from 'recoil'

const countState = atom({ key: 'count', default: 0 })

function Counter() {
  const [count, setCount] = useRecoilState(countState) //  Root 없으면 에러
  return <button onClick={() => setCount(c => c+1)}>{count}</button>
}

export default function App() {
  return (
    <RecoilRoot>
      <Counter />
    </RecoilRoot>
  )
}

```


## Valtio와 Mobx 사용하기

> Mobx... HOC... Observer... Class

우선, Valtio와 Mobx 모두 Proxy/Observable 기반의 반응형 상태 관리이다.
그리고, 내부적으로 어떤 필드가 읽혔는지를 추적해서, 해당 필드 변경시에만 리렌더를 한다.

하지만, Proxy를 사용하는 Valtio와 달리 Mobx는 observable로 객체 또는 값을 감싸고, 의존 그래프를 생성해서 관리한다.

이번엔 Mobx가 익숙하지 않을 것 같아, 코드로 설명한다.

기본적인 사용은 다음과 같다.

```tsx
import { proxy, useSnapshot } from 'valtio'

const state = proxy({ count: 0 })

function Counter() {
  const snap = useSnapshot(state) // 읽은 필드만 dependency
  return <button onClick={() => state.count++}>{snap.count}</button>
}
```

```tsx
import { makeAutoObservable } from 'mobx'
import { observer } from 'mobx-react-lite'

class Store {
  count = 0
  constructor() { makeAutoObservable(this) }
  inc() { this.count++ }
}
const store = new Store()

const Counter = observer(() => (
  <button onClick={() => store.inc()}>{store.count}</button>
))

```

우선, 요즘 리액트에서 클래스 기반의 상태가 조금 어색하게 느껴지긴 한다.
하지만, Mobx도 나름 강력한 장점?? 이라고 생각되는 부분도 있다.

비동기 처리 부분이다.
```tsx
// valtio
const state = proxy({ user: null, loading: false })

async function loadUser() {
  state.loading = true
  state.user = await fetch('/api/me').then(r => r.json())
  state.loading = false
}

// mobx
class Store {
  user = null
  loading = false
  
  constructor() { makeAutoObservable(this) }
  
  async loadUser() {
    this.loading = true
    this.user = await fetch('/api/me').then(r => r.json())
    this.loading = false
  }
}
```

Mobx는 자체적으로 "반응형 + 트랜잭션성"을 가진 상태관리 시스템이다.
그래서, 비동기 로직을 스토어 내부에 정의하는 게 자연스럽다.

아래와 같은 고수준 API 도 존재한다.
> 써보진 못했습니다...

```tsx
import { autorun, when } from "mobx"

const store = new Store()

// autorun: 상태 변화에 따라 비동기 로직 실행
autorun(() => {
  if (store.user) {
    console.log("User loaded:", store.user.name)
  }
})

// when: 특정 조건이 충족될 때까지 기다렸다가 동작 실행
when(
  () => store.user !== null,
  () => console.log("User is now available:", store.user)
)

store.loadUser()
```

이를 통해, 코드 상의 비동기 처리나 useEffect 를 작성할 필요도 없다.

## 정리

많은 라이브러리를 살펴보았지만, 결국 아래 세 가지가 이 책이 말하고자 하는 것 같다.
- 상태의 위치는 어디인가.
- 상태 갱신 스타일은 어떤가.
- 어떻게 구현되어 있는가.

이를 기반으로, 적절하게 상황에 맞는, 프로젝트에 맞는 라이브러리를 선택하길 바라는 것 같다.