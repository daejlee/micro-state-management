# 세가지 전역 상태 라이브러리의 유사점과 차이점

## Zustand와 Redux의 차이점

### Zustand와 Redux의 공통점 및 차이점 표

|                    | Redux                                                                 | Zustand                                                            |
| ------------------ | --------------------------------------------------------------------- | ------------------------------------------------------------------ |
| 데이터 흐름        | 단방향 데이터 흐름 강제, 액션 디스패치 필수, 예측 가능, 유지보수 용이 | 단방향 데이터 흐름 기반, 데이터 흐름에 대한 의견 없음, 개발자 자율 |
| 상태 갱신 방법     | 리듀서 기반                                                           | 리듀서 필요 없음                                                   |
| 디렉토리 구조 권고 | features 디렉토리 구조 제안, createSlice로 기능 디렉토리 패턴 설계    | 구조에 대한 의견 없음, 개발자 자율                                 |
| Immer 사용         | 기본적으로 사용                                                       | 미들웨어로 선택적 사용 가능                                        |
| 상태 전파          | 컨텍스트 사용, 런타임 스토어 주입 가능, 일부 사례에서 효과적          | 모듈 임포트 사용, 컨텍스트 사용은 선택적                           |

## Jotai와 Recoil을 사용하는 시점

- Jotai의 API는 Recoil에서 영감을 받음. 처음에는 의도적으로 Recoil에서 Jotai로 마이그레이션하는 데 도움이 되도록 설계됨

|                   | Jotai                                                 | Recoil                                        |
| ----------------- | ----------------------------------------------------- | --------------------------------------------- |
| API 설계          | Recoil에서 영감, 마이그레이션 용이                    | 자체 API, key 기반 atom/selector              |
| key 문자열        | key 문자열 생략, 객체 참조 기반                       | key 문자열 필수, 직렬화 및 지속성 구현에 유리 |
| atom/selector     | atom 함수가 atom과 selector 모두 대체, 일부 한계 존재 | atom과 selector 분리, 다양한 사용 사례 지원   |
| 구현 방식         | WeakMap 활용, 객체 참조 의존                          | key 문자열 기반, 객체 참조 의존하지 않음      |
| Provider 컴포넌트 | Provider 생략 가능, 개발자 친화적                     | Provider 필수, 명시적 상태 관리               |

## Valtio와 MobX 사용하기

### 갱신방식

MobX와 Valtio 모두 변경 가능한 상태를 사용하지만, 설계 방식에 차이가 있다.

- MobX는 클래스를 기반으로 상태와 메서드를 한 곳에 정의하는 방식을 권장한다. 객체지향 스타일에 익숙한 개발자에게 자연스럽고, 상태 변화의 흐름을 파악하기 쉽다.
- Valtio는 객체 기반으로, 상태와 갱신 함수를 분리해서 관리할 수 있다. proxy로 상태 객체를 만들고, 외부에서 갱신 함수를 정의하는 방식이라 코드 분할이 쉽고, 번들 크기 최적화에도 유리하다. 함수형 스타일을 선호하는 개발자에게 적합하다.

```ts
const timer = proxy({ secondsPassed: 0 });

export const increase = () => {
  timer.secondsPassed += 1;
};

export const reset = () => {
  timer.secondsPassed = 0;
};

export const useSecondsPassed = () => useSnapshot(timer).secondsPassed;
```

### 렌더링 최적화 방식

- MobX는 옵저버 패턴을 사용해 상태 변화를 감지하고, 실제로 변경된 컴포넌트만 렌더링한다. 예측 가능성이 높고, 복잡한 상태 관리에 적합하다.
- Valtio는 리액트의 훅을 활용해 동시성 렌더링에 강점을 가지며, 최신 리액트 패턴과 잘 어울린다. 함수형 컴포넌트와 자연스럽게 통합되어 효율적으로 사용할 수 있다.

## Zustand, Jotai, Valtio 비교하기

- 공통적인 철학: 작은 API를 제공하여, 개발자 필요에 따라 API를 조합할 수 있게 하려고 노력함.

### 상태가 어디에 위치하는가?

- **모듈 상태**: 리액트와 상관없이 자바스크립트 파일(모듈)에서 생성되는 상태. 여러 컴포넌트에서 쉽게 공유하거나, 리액트 외부에서도 접근할 수 있음.
- **컴포넌트 상태**: 리액트 컴포넌트의 생명주기와 연결되어 생성되고 관리되는 상태. 리액트 내부에서만 접근 가능하며, 외부에서는 직접 접근할 수 없음.

| 라이브러리       | 상태 위치         | 설명                                                                                                                                                                                                                          |
| ---------------- | ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Zustand / Valtio | 모듈(파일)        | - 리액트와 무관하게 자바스크립트 모듈(파일)에서 상태를 생성하고 관리. <br/> - 여러 컴포넌트에서 import해서 사용. <br/>- 리액트가 없어도 상태를 쓸 수 있음                                                                     |
| Jotai            | 컴포넌트/Provider | - 상태의 정의(아톰)는 모듈에서 하지만, 실제 값은 Provider 컴포넌트에 저장됨. <br/> - 여러 컴포넌트에서 Provider를 통해 값 공유. <br/>- 컴포넌트 생명주기와 밀접. <br/>- 리액트 컴포넌트 내부에서만 상태값을 읽거나 쓸 수 있음 |

> 리액트 외부(예: 일반 자바스크립트 함수)에서 Jotai의 상태값을 직접 읽거나 변경하는 것은 불가능하다. 만약 리액트 외부에서 상태를 다루고 싶다면, Zustand나 Valtio처럼 모듈 상태 기반 라이브러리를 사용하는 거나 드물게는 두 유형의 상태를 모두 사용하는 것이 합리적일 수 있다.

### 상태 갱신 스타일은 무엇인가?

- **불변 상태 모델(Zustand 등)**: 상태를 변경할 때마다 새로운 객체를 만들어야 하므로, 이전 상태와 변경된 상태를 쉽게 비교할 수 있다. 리액트의 렌더링 최적화와 잘 맞으며, 대규모 앱에서 성능 관리에 유리함.
- **가변 상태 모델(Valtio 등)**: 기존 객체를 직접 변경하므로 코드가 더 간단하고 직관적. 하지만 변경 추적이 어려울 수 있고, 리액트의 최적화와는 다소 맞지 않을 수 있다. 중첩된 객체를 다룰 때는 매우 편리함.

| 라이브러리 | 상태 갱신 방식       | 예시 코드                              | 특징                                                                                                                                                                             |
| ---------- | -------------------- | -------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Zustand    | 불변 상태 모델       | `setState({ count: state.count + 1 })` | - 객체를 직접 변경하지 않고, 새로운 객체를 만들어 상태를 갱신<br>- 변경 여부를 객체 참조로 쉽게 판단<br>- 리액트와 호환성이 좋고, 성능에 유리함<br>- 코드가 명확하고 예측 가능함 |
| Valtio     | 가변(변경) 상태 모델 | `++state.count`                        | - 기존 객체를 직접 변경<br>- 코드가 간결하고 직관적<br>- 깊이 중첩된 객체를 다룰 때 편리함<br>- 자바스크립트의 본래 동작과 유사함                                                |
