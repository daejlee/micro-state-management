# 세가지 전역 상태 라이브러리의 유사점과 차이점

앞에서 Zustand Jotai Vatio 라는 세가지 전역상태 라이브러리르 소개했다. 이번 장에서는 세 라이브러리의 유사점과 차이점을 알아본다. 이 세가지 라이브러리는 몇가지 특징을 가지고 있다.

## + 공통 관점으로 먼저 정렬해두기

세 라이브러리는 모두 React 훅과 잘 맞물리도록 설계되었고, “필요한 것만 다시 그리기”라는 철학을 공유한다.

다만 이 철학을 구현하는 위치와 수단이 다르다. `Zustand`는 불변 상태 모델을 기본으로 하여 셀렉터를 통해 필요한 조각만 구독하고,

`Jotai`는 상태를 atom 단위로 잘게 쪼개어 해당 atom을 읽는 컴포넌트만 반응시키며,

`Valtio`는 Proxy 추적과 snapshot 읽기를 이용해 실제로 읽힌 경로가 바뀔 때만 리렌더링을 유발한다.

즉, 셋 모두 “부분 리렌덩링”을 노리지만, 최적화의 지점이 선택 로직(Zustand), 단위 분해(Jotai), 접근 경로 추적(Valtio)로 갈라진다. 이 차이 때문에 팀의 코딩 습관과 사고 흐름이 꽤 달라지며, 실전에서 “어디서 버그가 생겼는가”를 추적하는 방식도 달라진다.

세 라이브러리는 모두 마이크로 상태 관리에 적합한 기본 기능을 제공하지만 코딩 스타일과 렌더링 최적화에 대한 접근 방식이 다르다.

## Zustand와 Redux의 차이점

두 라이브러리는 모두 전역 상태를 안전하고 예측 가능하게 관리하려는 같은 목적을 공유하지만, 어디에서 규칙을 강제하고 무엇을 개발자에게 맡길 것인가라는 철학의 차이에서 갈라진다.

```js
import { Provider, useDispatch, useSelector } from "react-redux"; // 컨텍스트 Provider를 통해 주입

const counterSlice = createSlice({
	// slice: 상태 + 리듀서를 한 군데 묶음
	name: "counter",
	initialState: { value: 0 }, // 상태는 항상 불변 갱신 전제
	reducers: {
		increment(state) {
			state.value += 1; // 실제로는 불변 복제본이 생성
		},
	},
});

export const { increment } = counterSlice.actions; // 액션
const store = configureStore({ reducer: { counter: counterSlice.reducer } }); // 스토어 구성

function Counter() {
	const value = useSelector((s) => s.counter.value); //  counter.value만 읽음
	const dispatch = useDispatch(); // 디스패치로만 상태 변경
	return <button onClick={() => dispatch(increment())}>{value}</button>;
}

export function App() {
	return (
		<Provider store={store}>
			<Counter />
		</Provider>
	);
}
```

```js
import { create } from "zustand";

type State = {
	value: number,
	inc: () => void,
};

export const useStore =
	create <
	State >
	((set) => ({
		// 모듈 단위 싱글톤 store
		value: 0,
		inc: () => set((s) => ({ value: s.value + 1 })), // 불변 갱신
	}));

function Counter() {
	const value = useStore((s) => s.value); // 셀렉터
	const inc = useStore((s) => s.inc); // 액션을 직접 호출 디스패치 객체 불필요
	return <button onClick={inc}>{value}</button>;
}

export function App() {
	return <Counter />; // Provider 없이 바로 사용
}
```

위 두 구현을 나란히 보면, Redux는 디스패치 → 리듀서 → 새 상태라는 엄격한 흐름이 보이는 대신 사용성은 조금 의식적이고,

Zustand는 스토어 함수 호출 → 부분 상태 교체가 곧 액션이어서 간결하다.

## ## Jotai와 Recoil을 언제 쓰면 좋은가 — 같은 문제를 놓고 멘탈 모델로 비교하기

두 라이브러리는 모두 “리액트 친화적인 전역/공유 상태”를 목표로 하지만, 최적화의 단위와 상태를 조직하는 방식이 꽤 다르다. 이 차이는 단순 취향이 아니라 팀의 개발 흐름과 디버깅/운영 코스트까지 바꾼다. 아래에서는 같은 요구(작은 전역 상태, 파생 값, 일부 동적 컬렉션)를 Jotai와 Recoil로 각각 풀어 보며, 어떤 시점에 무엇을 고르면 더 편한지 길게 설명한다. 코드 블록은 ````` 로 감싸고, 설명은 코드 옆 주석으로 달아 두었다(오타가 아주 살짝 있을 수 있음 — 의도된 인간미…).

---

## Jotai를 선택할 때의 감각과 시점

Jotai는 atom을 가장 작은 상태 단위로 삼아서, 컴포넌트가 “진짜로” 읽는 atom만 리렌더를 유발한다. 점진적 도입이 쉽고, 기존 코드에 살짝 덧대며 걷기도 수월하다. 파생 상태 역시 또 다른 atom(읽기 전용/쓰기 지원 둘 다 가능)으로 선언하므로, “계산을 어디에 둘 것인가?”라는 고민이 자연스럽게 코드 구조로 녹아든다. Provider가 선택 사항이라 간단한 앱/위젯은 Provider 없이도 잘 굴러간다. 반대로, 원자 수가 많아지면 네이밍/폴더링/의존 관계가 복잡해질 수 있어 팀 규칙이 필요하다.

```js
import { atom, useAtom } from "jotai";

const textAtom = atom(""); // 원시 atom
const countAtom = atom(0);

//파생 atom
const lengthAtom = atom((get) => get(textAtom).length);

const uppercaseAtom = atom(
	(get) => get(textAtom).toUpperCase(), // 읽기
	(_get, set, nextUpper: string) => set(textAtom, nextUpper.toLowerCase()) // 원자 업데이트
);

export function Counter() {
	const [n, setN] = useAtom(countAtom); // 이 컴포넌트는 count만 구독
	return <button onClick={() => setN((x) => x + 1)}>{n}</button>; // 불변 갱신은 Jotai 내부에서 처리
}

export function TextBox() {
	const [t, setT] = useAtom(textAtom); // text만 구독 count 변화에 반응없음
	return <input value={t} onChange={(e) => setT(e.target.value)} />;
}

export function Stats() {
	const [len] = useAtom(lengthAtom); // 파생만 읽음
	const [caps] = useAtom(uppercaseAtom); // 읽기 전용처럼 사용 가능
	return (
		<p>
			{len} / {caps}
		</p>
	);
}
```

Jotai 시점 요약: 팀이 “최소 API로 빠르게 조립”하고 싶고, 상태를 작게 쪼갠 설계가 맞으며, Provider 없이도 굴러가는 소형·중형 기능부터 차근히 전역화하려는 상황에서 특히 편하다. Suspense/비동기 atom도 자연스럽게 다룰 수 있어 데이터 패칭을 *작은 단위*로 흩뿌리기 좋다.

다만 아톰이 많아지면 이름 짓기/구성이 중요하고, 대규모 직렬화/복구가 핵심 요구라면 Recoil식 키-그래프의 편의가 그리워질 수 있다(여기서 팀 취향이 갈림).

---

## Recoil을 선택할 때의 감각과 시점

Recoil은 키(key)로 식별되는 atom과 selector를 중심으로, 상태를 명시적으로 관리한다.

```js
import {
	atom,
	selector,
	RecoilRoot,
	useRecoilState,
	useRecoilValue,
} from "recoil";

// 1) 키 기반 atom
const textState =
	atom <
	string >
	{
		key: "textState", // 전역적으로 유일
		default: "",
	};

// selector
const lengthState =
	selector <
	number >
	{
		key: "lengthState",
		get: ({ get }) => get(textState).length, // 파생 값 계산
	};

export function TextBox() {
	const [t, setT] = useRecoilState(textState); // 읽기, 쓰기
	return <input value={t} onChange={(e) => setT(e.target.value)} />;
}

export function Stats() {
	const len = useRecoilValue(lengthState); // 읽기 전용
	return <p>len: {len}</p>;
}

export function App() {
	return (
		<RecoilRoot>
			{" "}
			{/* Provider 필수 → 주입 경계가 명확 */}
			<TextBox />
			<Stats />
		</RecoilRoot>
	);
}
```

Recoil 시점 요약: 앱이 커지고, 상태를 직렬화/복원해야 하며, 파생 관계를 명시적인 그래프로 관리하고 싶은 팀이면 Recoil이 편하다. 반면, 작은 기능을 빨리 붙이는 초반에는 키/설정의 의식 비용이 부담일 수 있다.

### 그래서 둘은 어떤차이라고?

- 작게 쪼개서 빠르게 움직이고, Provider 없이도 가볍게 시작하고 싶고, Suspense/비동기 atom을 작은 단위로 섞어 쓰고 싶다면 Jotai가 알맞다. 다만 원자 관리 규칙을 미리 정하지 않으면 _아톰이 우후죽순_ 늘어날 수 있다(리엑트 초보 팀이면 특히).
- 직렬화/복구/명시적 그래프/키 기반 도구가 중요하고, 대규모 앱에서 상태 관계를 눈에 보이는 규칙으로 관리하고 싶다면 Recoil이 편하다. 다만 초기 의식(키 부여, 패밀리 설계, Provider 경계)이 조금 귀찮고, 개념 비용은 분명히 있다.

둘 다 “필요한 것만 다시 그리기”를 다른 경로로 달성한다. 팀이 어디에서 생각을 더 하고 어디에서 단순함을 택할지를 정하면, 선택은 거의 저절로 결정된다. (사족: 작은 사이드 프로젝트는 Jotai로 뚝딱, 조직·규모·감사 가능성이 중요한 제품은 Recoil로 질서 있게 — 라고 살짝은 과장해 요약할 수도 있겠다.)

## Zustand · Valtio · Jotai 요약

**Zustand**는 불변(immutable) 상태 모델 위에서 모듈 스코프 store를 만들고 `selector`로 필요한 조각만 구독해 리렌더링을 통제하는 방식이라, API가 단순하고 도입이 빠르며(Provider 없어도 됨), 미들웨어/DevTools로 직렬화·퍼시스턴스도 쉬운 편이다; 다만 셀렉터가 매 렌더 새 참조를 만들지 않도록 주의해야 하고, 팀 규칙이 없으면 액션 함수가 비대해질 수 있다.

**Valtio**는 Proxy 기반의 가변(mutable) 모델로 “수정은 프록시에, 읽기는 snapshot으로”라는 규칙을 두고 **접근 경로 추적**으로 실제 읽힌 부분만 다시 그려 리렌더릉 범위를 최소화한다; 문법이 매우 직관적(대입/푸시 그대로)이라 생산성이 높지만, snapshot-읽기/프록시-쓰기 분리를 깜빡하면 미묘한 버그가 날 수 있다.  
**Jotai**는 상태를 **atom** 단위로 잘게 쪼개고(필요 시 파생 atom), 해당 atom을 읽는 컴포넌트만 반응하므로 미세한 최적화가 자연스럽다; Provider가 선택 사항이고 API 표면이 작아 점진 도입이 쉽지만, 아톰이 많아지면 네이밍/구조 관리가 필요하고 대규모 직렬화·복원은 Recoil류보다 손이 더 간다.

**언제 무엇을?** 빠른 실험·작은 팀·간결한 전역 상태면 **Zustand**, 대입 기반의 직관적 모델링과 경로 추적으로 큰 리스트/대시보드 최적화가 필요하면 **Valtio**, 상태를 원자적으로 나눠 미세 제어·Suspense 친화적 파생 구성이 필요하면 **Jotai**가 어울린다.
