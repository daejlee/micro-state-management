# 11 - 세 가지 전역 상태 라이브러리의 유사점과 차이점

### `Zustand`

- 사용법, 스토어 모델 측면에서 Redux와 유사하지만, 리듀서를 기반으로 하지 않음

### `Jotai`

- API 측면에서 Recoil과 유사하지만, 선택자 기반 아님
- 렌더링 최적화를 위한 최소한의 API를 제공하는 것이 목표

### `Valtio`

- 변경 가능한 갱신 모델 측면에서 MobX와 조금 유사하지만, 렌더링 최적화 구현 방식이 매우 다름

# Zustand와 Redux

- 단방향 데이터 흐름을 기반으로 함
- action(상태를 변경하라는 명령) 실행 → 상태 갱신 → 상태가 필요한 곳에 전파
- 위와 같이 디스패치와 전파를 분리하는 것은 데이터의 흐름을 단순화하고, 시스템을 예측 가능하게 만듬

❗️ 두 라이브러리는 **상태를 갱신하는 방법**에 차이가 있다

- Redux는 리듀서에 기반
  - 리듀서 : 이전 상태와 action 객체를 받아 새로운 상태를 반환하는 순수 함수
  - 엄격하지만, 예측 가능성 높음

### `Redux Toolkit` 사용 예제

- Slice 안에서 상태와 액션을 한번에 관리
- Immer 사용으로 불변성 처리 신경 안 써도 됨

```tsx
// Slice 정의 (상태 + 상태 변경 로직)
const initialState = { value: 0 };

const counterSlice = createSlice({
  name: "counter",
  initialState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
  },
});

// Action 추출
export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

- `reducers` 안에서 상태 변경 로직을 정의

```tsx
// 카운터 컴포넌트
function Counter() {
  // 상태 조회
  const count = useSelector((state: { counter: { value: number } }) => state.counter.value);

  // 액션 호출
  const dispatch = useDispatch();

  return (
    <div>
      <button onClick={() => dispatch(increment())}>Increment</button>
      <span>{count}</span>
      <button onClick={() => dispatch(decrement())}>Decrement</button>
    </div>
  );
}
```

```tsx
const App = () => (
  <Provider store={store}>
    <div>
      <Counter />
      <Counter />
    </div>
  </Provider>
);
```

- store를 Provide로 앱 전체에 공급
  - store를 import하지 않고 훅으로 접근 → 컴포넌트는 store 구조를 몰라도 됨
  - 여러 카운터가 같은 상태 공유

### `Zustand` 사용 예제

```tsx
// store 정의 (상태 + 액션 모두 포함)
export const useStore = create<State>((set) => ({
  counter: { value: 0 },
  counterActions: {
    increment: () => set((state) => ({ counter: { value: state.counter.value + 1 } })),
    decrement: () => set((state) => ({ counter: { value: state.counter.value - 1 } })),
    incrementByAmount: (amount: number) => set((state) => ({ counter: { value: state.counter.value + amount } })),
  },
}));
```

- 상태와 액션을 한 곳에서 정의
  - 리듀서 로직은 액션 함수 내부에서 구현
- Redux와 같은 slice/dispatch 구조가 아닌, 직접 store를 업데이트

```tsx
// 카운터 컴포넌트 (store 직접 접근)
export function Counter() {
  const count = useStore((state) => state.counter.value);
  const { increment, decrement } = useStore((state) => state.counterActions);

  return (
    <div>
      <button onClick={increment}>Increment</button>
      <span>{count}</span>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
}
```

- 컴포넌트가 `useStore` 훅으로 직접 store 접근
- 필요한 상태와 액션을 선택적으로 가져올 수 있음

```tsx
const App = () => (
  <div>
    <Counter />
    <Counter />
  </div>
);
```

- 공급자 컴포넌트 필요하지 않음

## 두 라이브러리 비교

| 구분               | **Redux**                                                      | **Zustand**                              |
| ------------------ | -------------------------------------------------------------- | ---------------------------------------- |
| **설계 철학**      | `createSlice` 기반, 기능 디렉토리 패턴 권장 → 대규모 앱에 적합 | 구조에 대한 제약 없음, 자율성이 크다     |
| **불변성 처리**    | 기본적으로 **Immer** 내장                                      | 선택적으로 **Immer** 사용 가능           |
| **접근 방식**      | **Context(Provider)** 사용, 런타임에 스토어 주입 가능          | 모듈 임포트로 바로 사용 (Context는 옵션) |
| **상태 갱신 방법** | 액션 객체를 **dispatch**해야 함                                | 스토어에 정의된 함수 직접 호출           |

# Jotai와 Recoil

> 의도적으로 Recoil → Jotai 마이그레이션이 가능하도록 Jotai를 설계했다

### `Recoil` 사용 예제

```tsx
const textState = atom({
  key: "textState",
  default: "",
});

const TextInput = () => {
  const [text, setText] = useRecoilState(textState);
  return (
    <div>
      <input type="text" value={text} onChange={(e) => setText(e.target.value)} />
      <br />
      Echo: {text}
    </div>
  );
};
```

- atom을 사용하여 상태 생성
  - key, default 두 가지 속성 필요
  - `useRecoilState`로 정의한 상태 사용 가능

```tsx
const charCountState = selector({
  key: "charCountState",
  get: ({ get }) => get(textState).length,
});

const CharacterCount = () => {
  const count = useRecoilValue(charCountState);
  return <>Character Count: {count}</>;
};
```

- selector로 파생 상태 정의
  - key, get(파생 값을 반환하는 함수) 두 가지 속성 필요
  - get 함수는 selector 내부에서 다른 상태를 구독할 수 있도록 한다
- 위 예시에서 charCountState가 파생되어 있어, textState가 변경되면 CharacterCount는 리렌더링된다

```tsx
const CharacterCounter = () => (
  <div>
    <TextInput />
    <CharacterCount />
  </div>
);

const App = () => (
  <RecoilRoot>
    <CharacterCounter />
  </RecoilRoot>
);
```

- 상태 값을 저장하는 RecoilRoot(Provider) 필요

### `Jotai` 사용 예제

- api를 최소로 사용하는 것을 지향
  - 최소한의 사용을 위해 atom, useAtom 두 가지 함수가 필요

```tsx
const textAtom = atom(""); // 변수 이름 뒤에 Atom을 붙이는 것이 관례

const TextInput = () => {
  const [text, setText] = useAtom(textAtom);
  return (
    <div>
      <input type="text" value={text} onChange={(e) => setText(e.target.value)} />
      <br />
      Echo: {text}
    </div>
  );
};
```

```tsx
const charCountAtom = atom((get) => get(textAtom).length);

const CharacterCount = () => {
  const [count] = useAtom(charCountAtom);
  return <>Character Count: {count}</>;
};
```

- atom함수를 통해 파생 아톰을 만들 수 있다

```tsx
const CharacterCounter = () => (
  <div>
    <TextInput />
    <CharacterCount />
  </div>
);

const App = () => (
  <>
    <CharacterCounter />
  </>
);
```

- Jotai는 Provider를 선택적으로 사용 (전역 상태 분리나 SSR환경에서 필요할 수 있음)

## 두 라이브러리 비교

| 구분                   | **Recoil**                                        | **Jotai**                                                                     |
| ---------------------- | ------------------------------------------------- | ----------------------------------------------------------------------------- |
| **상태 식별**          | `key` 문자열 필수 (직렬화 가능, 지속성 구현 용이) | `key` 없음(참조 기반, WeakMap 활용) → 개발자 경험 ⬆️                          |
| **상태 단위**          | `atom`(기본 상태) + `selector`(파생 상태)         | `atom` 하나로 atom + selector 역할 모두 가능 (복잡한 경우에는 추가 함수 필요) |
| **직렬화/지속성**      | 용이 (`key` 기반으로 저장/복원이 가능)            | 상대적으로 불리 (참조 기반이라 따로 구현 필요)                                |
| **Provider 필요 여부** | `RecoilRoot` 필수                                 | `Provider` 생략 가능 (선택적 사용)                                            |

# Valtio와 MobX

- **`변경 가능한 상태`**를 기반으로 한다
- 문법이 매우 자연스럽고 간결
- 렌더링 최적화에 있어서는 Valtio는 훅, MobX는 HOC 사용

  - Valtio는 불변 상태와 변경 가능한 상태를 연결한다는 점에서 immer와 비슷하다.
    | 구분 | **Valtio** | **Immer** |
    | ------------------ | -------------------------------------------------------------- | ---------------------------------------------------------------------------- |
    | **상태 접근 방식** | 상태를 직접 변경 가능 | 상태를 불변 상태로 유지, draft(임시로 변경 가능한 복제 상태)에서만 변경 가능 |
    | **불변성 관리** | 내부적으로 Proxy를 사용해서 변경 추적 → 필요하면 불변처럼 동작 | 불변 상태를 기반으로 draft를 만들어, 변경 후 새로운 불변 상태 반환 |
    | **철학** | 변경 가능한 상태를 쓰면서, 필요 시 불변으로 변경 | 불변 상태를 기본으로, 일시적으로 변경 허용 |
  - **Valtio**

    ```tsx
    import { proxy } from "valtio";

    const state = proxy({ count: 0 });
    state.count += 1; // 직접 변경 가능
    ```

    - 직접 상태를 바꾸지만, 내부적으로 Proxy를 통해 구독자에게 변경 사항을 알려
    - 불변 상태처럼 안전하게 동작

  - **Immer**

    ```tsx
    import produce from "immer";

    const state = { count: 0 };
    const nextState = produce(state, (draft) => {
      draft.count += 1;
    });
    ```

    - 실제 상태는 불변
    - draft에서만 변경 가능한 것처럼 다루고, 최종적으로 새로운 불변 상태를 만들어 반환

### `MobX` 사용 예제

- MobX는 프레임워크에 구애받지 않는다 (리액트 관련 함수는 MobX React)

```tsx
class Timer {
  secondsPassed = 0;
  constructor() {
    makeAutoObservable(this);
  }
  increase() {
    this.secondsPassed += 1;
  }
  reset() {
    this.secondsPassed = 0;
  }
}

const myTimer = new Timer();

setInterval(() => {
  myTimer.increase();
}, 1000);

const TimerView = observer(({ timer }: { timer: Timer }) => (
  <button onClick={() => timer.reset()}>Seconds passed: {timer.secondsPassed}</button>
));

const App = () => (
  <>
    <TimerView timer={myTimer} />
  </>
);
```

- `observer`는 상태를 추적하고 변경 시 자동으로 리렌더링하는 HOC
  - 컴포넌트 안에서 observable 상태를 읽는 순간 MobX가 추적 시작
  - JSX에서 `timer.secondsPassed` 사용 → `timer.secondsPassed`에 의존하고 있다는 것을 추적

### `Valtio` 사용 예제

- 리액트를 위한 라이브러리 (다른 환경에서도 사용 가능한 바닐라 번들 존재)

```tsx
const myTimer = proxy({
  secondsPassed: 0,
  increase: () => {
    myTimer.secondsPassed += 1;
  },
  reset: () => {
    myTimer.secondsPassed = 0;
  },
});

setInterval(() => {
  myTimer.increase();
}, 1000);

const TimerView = ({ timer }: { timer: typeof myTimer }) => {
  const snap = useSnapshot(timer);
  return <button onClick={() => timer.reset()}>Seconds passed: {snap.secondsPassed}</button>;
};

const App = () => (
  <>
    <TimerView timer={myTimer} />
  </>
);
```

- proxy 함수를 통해 myTimer 인스턴스 정의
- `useSnapshot`은 JSX에서 사용된 상태를 추적하여, 상태가 바뀌면 자동으로 컴포넌트를 리렌더링하는 훅

## 두 라이브러리 비교

| 라이브러리 | 상태 구조         | 상태 갱신 & 렌더링 최적화                                                                                                |
| ---------- | ----------------- | ------------------------------------------------------------------------------------------------------------------------ |
| **MobX**   | 클래스 기반       | 옵저버 방식으로 상태 변경 추적 → 렌더링 최적화, 예측 가능성 높음                                                         |
| **Valtio** | 객체 기반 (Proxy) | 외부에서 상태 갱신 함수 정의 가능 → 코드 분할 최소화, 번들 크기 최적화 </br> 훅으로 렌더링 최적화 → 동시성 렌더링 친화적 |

# Zustand, Jotai, Valtio 비교

| 라이브러리  | 상태 위치                                           | 상태 갱신 스타일                                          |
| ----------- | --------------------------------------------------- | --------------------------------------------------------- |
| **Zustand** | 모듈 상태 – 모듈 수준에서 생성, React에 속하지 않음 | 불변 상태 모델, 액션 함수 안에서 set 사용                 |
| **Valtio**  | 모듈 상태 – Proxy 기반 객체, React에 연결 선택적    | 변경 가능한 상태 모델, 값 직접 수정, useSnapshot으로 구독 |
| **Jotai**   | 컴포넌트 상태 – atom 단위, React 생명주기에서 생성  | atom 업데이트 함수 사용, selector로 파생 상태 관리        |

- 리액트 외부에서 컴포넌트 상태에 접근하는 것은 불가능하기 때문에 컴포넌트 상태에 연결하기 위해서는 모듈 상태를 사용해야 한다
- 불변 상태 모델에서 상태를 갱신하려면 새 객체를 만들어야 한다
  - 참조를 비교하여 변경 사항이 있는지 파악 가능하다는 장점이 있다
  - 리액트가 대체로 불변 모델에 기반하기 때문에 호환성이 좋다
- 변경 가능한 상태 모델은 객체가 깊이 중첩된 경우에 편리하다
- Zustand, Jotai에서도 immer 사용이 가능하다
