# 8장. 사용 사례 시나리오 2: Jotai

## Jotai 이해하기

Jotai 를 사용해서 얻을 수 있는 이점은 두 가지다.

- 구문 단순성
- 동적 아톰 생성

### 이점1. 구문 단순성

```tsx
import { atom, useAtom } from 'jotai';

const countAtom = atom(0);

const Counter1 = () => {
  const [count, setCount] = useAtom(countAtom);
  const inc = () => setCount((c) => c + 1))
  return <>{count} <button onClick={inc}>+1</button></> 
}

const Counter2 = () => {
  const [count, setCount] = useAtom(countAtom);
  const inc = () => setCount((c) => c + 1))
  return <>{count} <button onClick={inc}>+1</button></> 
}
```

위와 같이 `atom`, `useAtom` 은 Jotai 가 제공하는 기본 함수이다.  
아톰은 작은 상태 조각이며, 리렌더링을 감지하는 최소 단위다.

`atom` 을 이용해 아톰을 정의하고, `useAtom` 을 사용해 컨텍스트를 사용하지 않고 아톰을 가져온다.

> 구문 단순성의 이점이 있지만, 새로운 기능이 추가되는 것은 아니다!

### 이점2. 동적 아톰 생성

> [공식문서 - atomFamily](https://jotai.org/docs/utilities/family)

Jotai 의 동적 아톰 생성은 키 기반으로 아톰을 생성하거나 재사용하는 기능이다.  
즉, 동일한 구조를 가진 여러 아톰을 반복적으로 만들 때 유용하다.  
`WeakMap`을 활용한 캐싱 전략이 활용되어, 메모리 관리 측면에서도 효율적이다.  

아래와 같이 사용할 수 있다.

```ts
import { atom } from 'jotai'
import { atomFamily } from 'jotai/utils'

const userAtomFamily = atomFamily((id: number) => atom({ id, name: '' }))

const user1Atom = userAtomFamily(1)
const user2Atom = userAtomFamily(2)
```

## 렌더링 최적화

zustand 사용 사례에서 살펴본 것과 같은 `store`와 `selector`를 이용한 방식을 하향식(top-down) 접근법이라고 한다.

아톰은 리렌더링을 감지하는 단위다.  
아톰은 이름처럼 원하는 만큼 작게 만들어서 리렌더링을 제어할 수 있지만, 이는 조작해야할 아톰의 수가 매우 많아지는 것을 의미한다.

따라서, Jotai는 기존 아톰으로 또 다른 아톰을 만들 수 있는 파생 아톰을 지원한다.

```ts
const personAtom = atom((get) => ({
  firstName: get(firstNameAtom),
  lastName: get(lastNameAtom),
  age: get(ageAtom),
}));
```

이 경우, `ageAtom`이 변경되면 `personAtom`도 변경되고, `personAtom`을 통해 `firstNameAtom`과 `lastNameAtom` 만 참조하는 경우에도 리렌더링된다.

따라서, `firstNameAtom`과 `lastNameAtom`만 필요한 경우, 아래와 같이 만들어야 한다.

```ts
const fullNameAtom = atom((get) => ({
  firstName: get(firstNameAtom),
  lastName: get(lastNameAtom),
}));
```

이런 방식을 상향식(bottom-up) 접근법이라고 한다.

## Jotai가 아톰 값을 저장하는 방식 이해하기

원시 아톰은 useState 처럼 동작하도록 설계됐다.  

중요한 것은 countAtom과 같은 아톰 구성이 직접 해당 값을 가지지 않는다는 것이다.  
실제 아톰 값을 저장하는 store가 따로 있다. 이 store에는 키가 아톰 구성 객체이고, 값이 아톰 값인 weakMap 객체가 있다. 

useAtom은 기본적으로 모듈 단위 store를 사용하지만, Jotai가 제공하는 Provider를 통해 컴포넌트 레벨의 store를 사용할 수 있다.

```ts
import { atom, useAtom, Provider } from "jotai";

const Counter = ({ countAtom }) => {
  const [count, setCount] = useAtom(countAtom);
  const inc = () => setCount((c) => c + 1);
  return <>{count} <button onClick={inc}>+1</button></> 
};

const App = () => (
    <>
      <Provider>
        <h1>First Provider</h1>
        <Counter/>
        <Counter/>
      </Provider>
      <Provider>
        <h1>Second Provider</h1>
        <Counter/>
        <Counter/>
      </Provider>  
    </>
)
```

## 배열 구조 추가하기

먼저 atom값으로 배열을 다루는 예시는 다음과 같다.

```ts
const todosAtom = atom([]);

const TodoList = () => {
  const [todos, setTodos] = useAtom(todosAtom);

  const removeTodo = useCallback((id: string) => setTodos(
    (prev) => prev.filter((item) => item.id !== id)
  ), [setTodos])

  const ToggleTodo = useCallback((id: string) =>
    setTodos((prev) =>
      prev.map((item) =>
        item.id === id ? { ...item, done: !item.done } : item
      )
    ), [setTodos]);

  return (
    <div>
      {todos.map((todo) => (
        <MemoedTodoItem 
          key={todo.id} 
          todo={todo} 
          removeTodo={removeTodo}
          toggleTodo={toggleTodo} 
        />
      ))}
    </div>
  );
};

// NewTodo 생략
```

이렇게 작성한 코드는 한 가지의 문제점이 있다.

> id 관련된 이유를 아시는 분...
> 이 id 가 atom 의 캐싱 키로 사용되어서 그런가요...?

- 단일 요소의 수정을 위해 todos 배열 전체가 갱신된다.

Jotai는 이 문제를 해결하기 위해 `Atoms-in-Atom` 을 제시한다.

우선, PrimitiveAtom 을 사용해 TodoAtom 타입을 생성한다.

```ts
type TodoAtom = PrimitiveAtom<Todo>
```

이 원시 아톰 타입을 이용해 todoAtoms 구성한다.
```ts
const todoAtoms = atom<TodoAtom[]>([]);
// todoAtomsAtom은 좀...
```
