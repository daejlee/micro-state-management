# 8. Jotai

Zustand와 달리 Jotai는 컴포넌트 상태를 사용하고, Zustand와 마찬가지로 불변 상태 모델이다. 컨텍스트 및 구독 패턴을 기반으로 한다.

작은 상태 조각인 아톰을 모델로 삼으며, 의존성을 추적하고 리렌더링을 감지할 수 있다. 내부적으로 컨텍스트를 사용하고 아톰 자체는 값을 가지지 않으므로 모듈 상태와 달리 한번 정의한 아톰을 재사용할 수 있다.

## Jotai 이해하기

컨텍스트에 비해 Jotai가 가지는 두 가지 이점이 있다.

- 구문 단순성
- 동적 아톰 설정

### 구문 단순성

```jsx
import { atom, useAtom } from 'jotai';

const countAtom = atom(0);

const Counter1 = () => {
  const [count, setCount] = useAtom(countAtom);
  ...
}
const Counter2 = () => {
  const [count, setCount] = useAtom(countAtom);
  ...
}
```

아톰은 작은 상태 조각이며 리렌더링을 감지하는 최소 단위다. atom 함수는 아톰 정의를 생성하고, 초깃값을 지정하는 인수를 받는다.

```jsx
const App() => {
  <>
    <Counter1 />
    <Counter2 />
  </>
}
```

아톰을 사용할 때는 provider가 필요하지 않다. 5장에서 다룬 컨텍스트의 ‘기본 스토어’로 인해 가능하다. 서로 다른 하위 트리에 대해 다른 값을 제공해야 하는 경우 선택적으로 provider를 사용하면 된다.

아톰이 많아져도 기본적으로 한 줄의 아톰 정의만 추가하면 된다.

쓰기가 간단하다는 장점인데, 뭐 새로운 기능을 제공하는 건 아니다.

### 동적 아톰 생성

아톰은 리액트 컴포넌트 생명 주기에서 생성, 소멸될 수 있다. 다중 컨텍스트 방식에선 새로운 상태 === 새로운 Provider 추가를 의미하기 때문에 리액트 컴포넌트 생명 주기에서 생성, 소멸될 수 없다.

Jotai는 5장의 리액트 컨텍스트와 구독을 이용한 컴포넌트 상태 공유에서 배운 내용을 기반으로 한다. Jotai의 스토어는 아톰 구성 객체와 아톰 값으로 구성된 WeakMap 객체다. 여기서의 “아톰 구성 객체(atom config object)”는 atom 함수로 생성하고, “아톰 값(atom value)”는 useAtom 훅의 반환 값이다. Jotai의 구독은 아톰 기반이므로 useAtom 훅이 store에 있는 특정 아톰을 구독한다는 것을 의미한다.

아톰 기반 구독은 불필요한 리렌더링을 피할 수 있는 기능을 제공한다.

## 렌더링 최적화

store와 셀렉터 접근 방식을 탑다운 접근법이라고 한다. 모든 것을 저장하는 store를 생성하고 필요에 따라 store에서 상태를 선택한다.

```jsx
const personStore = createStore({
  firstName: 'React',
  lastName: 'Hooks',
  age: 3,
});

const selectFirstName = (state) => state.firstName;
const selectSecondName = (state) => state.secondName;
```

아톰은 원시 타입만큼 작게 만드는 것이 가능하지만, 동시에 조작할 아톰이 너무 많을 수 있다는 것을 의미한다. Jotai에는 파생 아톰이라는 개념이 있다.

```jsx
const firstNameAtom = atom('React');
const lastNameAtom = atom('Hooks');
const ageAtom = atom(3);

const personAtom = atom((get) => ({
  firstName: get(firstNameAtom),
  lastName: get(lastNameAtom),
  age: get(ageAtom),
}));
```

read 함수는 다른 아톰을 참조하고 값을 가져올 수 있는 get 인수를 받는다. 위와 같이 firstNameAtom, lastNameAtom, ageAtom 중 하나만 값이 바뀌어도 갱신된다. 이를 의존성 추적(dependency tracking)이라고 하며 jotai에서 자동으로 수행한다.

<aside>

    💡read 함수 === atom 함수의 첫 번째 인수로 들어가는 함수
    의존성 추적은 동적이며 조건부 평가에서도 작동.

    (get) ⇒ get(a) ? get(b) : get(c)라 해도,
    a가 참이면 의존성은 a, b이고 a가 거짓이면 의존성은 a, c이다.

</aside>

```jsx
const person = useAtom(personAtom);
return (
  <>
    {person.firstName} {person.lastName}
  </>
);
// ageAtom의 값이 변경되면 리렌더링됨..

// 리렌더링을 피하기 위해 파생 아톰을 만들어야 한다.
const fullNameAtom = atom((get) => ({
  firstName: get(firstNameAtom),
  lastName: get(lastNameAtom),
}));
// 이렇게 되면 ageAtom이 변경되도 리렌더링되지 않는다.
```

위와 같은 방식을 바텀업 접근법이라고 한다. 작은 아톰을 만들고 이들을 결합해 더 큰 아톰을 만들어나간다. 리렌더링을 최적화한다.

스토어-선택자 방식으로 위 바텀업 접근을 따라하면, 의도대로 동작하지 않는다. age가 바뀌면 selectFullName 함수가 다시 평가되고 동일한 속성을 가진 새 객체를 반환한다. 이를 해결하기 위해 사용자가 동등 함수를 만들거나 메모이제이션을 사용해야 한다. Jotai는 그런 것들이 필요 없다.

## Jotai가 아톰 값을 저장하는 방식

Jotai가 컨텍스트를 사용하여 아톰 값을 저장하고, 아톰을 재사용하는 방법을 알아본다.

```tsx
const countAtom = atom(0);
```

구현의 측면에서 바라본다면 countAtom은 아톰 동작을 나타내는 속성들을 가진 객체다. 중요한 것은 countAtom과 같은 아톰 구성이 직접 해당 값을 가지지 않는다는 것이다.

아톰 값을 저장하는 store는 따로 존재하고, 그 store에는 아톰 구성 객체가 키이며 값이 아톰 값인 WeakMap 객체가 있다.

useAtom은 기본적으로 모듈에서 정의된 기본 store를 사용한다. 다만 Jotai는 Provider 컴포넌트를 제공하므로 컴포넌트 레벨에서 store를 생성할 수도 있다.

```tsx
import { atom, useAtom, Provider } from "jotai";

const Counter = ({ countAtom }) => {
  const [count, setCount] = useAtom(countAtom);
  ...
};

// 서로 다른 store를 사용한다.
const App = () => (
  <>
    <Provider>
      <Counter />
    </Provider>
    <Provider>
      <Counter />
    </Provider>
  </>
);
```

countAtom 자체가 값을 가지지 않으므로, countAtom을 여러 Provider 컴포넌트에서 재사용할 수 있다.

즉, 아톰 구성은 값을 가지지 않으므로 재사용이 가능하다.

## 배열 구조 추가하기

Jotai에서 배열을 처리하는 방법을 알아본다. 기존의 방식은 두 가지 단점이 존재한다.

- 단일 요소 변경을 위해 배열 전체를 갱신해야 한다. memo를 한다면 특정 요소가 변경되지 않는 한 컴포넌트는 리렌더링되지 않지만, 이상적으로는 특정한 memo 컴포넌트가 리렌더링되게 감지하는 것이 좋다.
- 요소의 id 값을 사용하지 않고도 배열을 다룰 수 있다면 좋을 것이다.

<aside>

    💡이상적으로는 특정한 memo 컴포넌트가 리렌더링되게 감지하는 것이 좋다.

    이게 무슨 말이지? 했는데 이런 말로 이해할 수 있을 것 같다.
    현재는 배열 요소가 변경되면, 배열 전체를 갱신한다. 배열 자체가 리렌더링 되는것은 못 막음.
    물론 메모한 요소들은 리렌더링되지 않지만.

    아예 그냥 배열 요소 자체를 감지하는 것이 더 낫지 않겠냐? 라는 말이다.

</aside>

이 문제를 해결하기 위해 Atoms-in-Atom을 제시한다. 이는 Jotati의 멘탈 모델과 더 일관성이 있다.

<aside>

    💡멘탈 모델..?

    어떤 개념이나 시스템을 이해하고 사용하는 데 있어, 머릿속에서 형성되는 직관적 사고 구조나 개념적 프레임워크를 의미한다.
    사용자가 그 라이브러리/프레임워크를 어떻게 '생각하고' 다루는지가 자연스럽게 일관되게 맞아떨어지는가? 에 대한 것.

</aside>

```tsx
type Todo = {
  // id가 필요 없다.
  title: string;
  done: boolean;
};

type TodoAtom = PrimitiveAtom<Todo>;

const todoAtomsAtom = atom<TodoAtom[]>([]); // TodoAtom 배열을 나타내는 atom
// 즉, atom안의 atoms다. atoms-in-atom
```

```tsx
const TodoItem = ({
  todoAtom,
  remove,
}: {
  todoAtom: TodoAtom;
  remove: (todoAtom: TodoAtom) => void;
}) => {
  const [todo, setTodo] = useAtom(todoAtom);
  return (
    <input onChange={() => setTodo(
      (prev) => ({ ...prev, done: !prev.done })
    )}/>
      ...
    <button onClick={() => remove(todoAtom)}>
      Delete
    </button>
  );
};
/** 원래는 이런 식으로..
setTodos((prev) => [...prev, { id: nanoid(), title: text, done: false },]);
```

onChange 콜백이 간단하며 배열의 요소라는 사실에 의존하지 않는다.

```tsx
const TodoList = () => {
  const [todoAtoms, setTodoAtoms] = useAtom(todoAtomsAtom);
  const remove = useCallback(
    (todoAtom: TodoAtom) =>
      setTodoAtoms((prev) => prev.filter((item) => item !== todoAtom)),
    [setTodoAtoms]
  );
  return (
    <div>
      {todoAtoms.map((todoAtom) => (
        <MemoedTodoItem
          key={`${todoAtom}`} // 오호!
          todoAtom={todoAtom}
          remove={remove}
        />
      ))}
    </div>
  );
};
```

<aside>

```tsx
const a1 = atom(1);
const a2 = atom(2);

console.log(String(a1)); // "atom<0.xxxxx>"
console.log(String(a2)); // "atom<0.yyyyy>"
console.log(a1 === a2); // false (당연히 다른 객체)
```

    Jotai에서 생성된 각 atom은 생성 시점에 **유일한 내부 ID**를 갖는다. 아톰 구현을 살펴보면,

```tsx
function atom<Value>(read: Read<Value>, write?: Write<Value>) {
  const key = `atom<${++keyCount}.${Math.random().toString(36).slice(2)}>`;
  const atom = { toString: () => key, ... } // 문자열 변환 시 UID 반환
  return atom;
}
```

</aside>

아톰 구성이 문자열로 평가될 때 UID를 반환하여 id가 필요가 없다. 또한 Atoms-in-Atom을 다루므로 배열 요소 중 하나가 toggleTodo로 갱신되도 todoAtomsAtom은 변경되지 않는다. 자연스럽게 리렌더링을 줄인다.

Atoms-in-Atom을 정리해보자.

- 배열 아톰이 아톰이 요소인 배열을 보관한다.
- 배열에 새로운 요소를 추가하려면 새로운 아톰을 생성해 추가해야 한다.
  (당연하겠찌 그래야 UID 생성될거아녀)
- 아톰 구성은 문자열로 평가될 수 있으며 이것이 UID를 반환한다.
- 요소를 렌더링하는 컴포넌트는 각 컴포넌트에서 아톰 요소를 사용한다. 배열이 아니라.
  이렇게 요소의 값을 쉽게 변경하고 리렌더링을 피한다. (마치 배열의 요소가 아닌 것 처럼)
  (즉, `setTodoAtoms`는 호출되지 않음)
