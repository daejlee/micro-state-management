# Jotai를 활용한 상태 관리

이 장에서는 릭트 기반 마이크로 상태 관리 라이브러리 Jotai를 중심으로 실전 사례를 다룰것입니다.  
Jotai는 원자(atom) 개념을 활용해 상태를 작고 독립적으로 구성하며, ₩Context₩ + ₩Subscription₩ 기반으로 자동 최적화가 가능한 라이브러리입니다. Jotai는 내부적으로 Context 패턴을 사용하는것 또한 확인할 수 있었습니다.

## Jotai의 핵심 개념

- atoms: 상태의 최소 단위로 읽기/쓰기 가능한 독립 상태
- Derived atoms: 다른 atom을 기반으로 계산된 상태 (불변성 보장) [흠 잘 이해안됨]
- selector 기반 리렌더 최적화: 컴포넌트는 atom의 일부 값만 구독 → 다른 atom 변경 시 영향 없음
- Context + 구독 기반 내부 구조로, atom 정의는 재사용 가능하고 module state보다 유연함

## 기본 사용 예시

```js
import { atom, useAtom } from "jotai";

// Primitive atom 정의 (기본 상태)
const countAtom = atom(0);

// Component 내부 상태 읽기/쓰기
function Counter() {
	const [count, setCount] = useAtom(countAtom);
	return <button onClick={() => setCount((prev) => prev + 1)}>{count}</button>;
}
```

- `atom(0)` 은 기본 숫자 상태를 정의한 가장 간단한 atom입니다.
- `useAtom(countAtom)` 훅을 통해 읽기/쓰기 가능한 상태 훅처럼 동작하며, 컴포넌트가 해당 atom을 구독합니다.
- count가 바뀔 때만 리렌더링되어 효율적인 업데이트가 가능합니다.

---

## Derived atom 예시 (파생 상태 정의)

```js
// 파생된 상태 계산
const doubleAtom = atom((get) => get(countAtom) \* 2);

// 읽기 전용 컴포넌트
function DoubleDisplay() {
const [double] = useAtom(doubleAtom);
return <p>2배 값: {double}</p>;
}
```

- `doubleAtom`은 `countAtom`에 기반하여 자동으로 값을 계산합니다
- `countAtom`이 변경되면 `doubleAtom`도 자동 "갱신"되며, 효율적으로 파생 상태를 관리할 수 있습니다

---

## 배열 상태와 Atoms-in-Atom 패턴 (가장 흥미로운 부분)

```js
// 배열 상태와 배열 내 atom 생성
const todosAtom = atom([{ id: 1, text: "하나", done: false }]);
const selectedTodoAtom = atom(
	(get) => get(todosAtom).find((todo) => todo.done),
	(get, set, update) => {
		const todos = get(todosAtom).map((todo) =>
			todo.id === update.id ? { ...todo, done: !todo.done } : todo
		);
		set(todosAtom, todos);
	}
);
```

배열 상태를 atom으로 관리하고, 배열 내부 아이템을 선택/갱신하는 파생 atom을 따로 정의함으로써 특정 데이터만 갱신 / 구독 가능
Atoms-in-Atom 패턴은 깊숙한 구조에서도 리렌더링을 최소화하기 위한 핵심 기법입니다.

## Jotai의 차별점

Jotai는 다른 전역 상태 관리 라이브러리들과 비교했을 때 다음과 같은 독특한 특징과 장점을 가집니다

### Jotai의 불변성 관리 vs 다른 상태 관리 라이브러리

Jotai는 불변성(Immutability)을 자동으로 보장하지 않으며, 사용자가 직접 불변성을 유지해야 합니다. 이는 다른 라이브러리들과 가장 큰 차별점 중 하나입니다. (이게 뭔말이지...)

---

### Jotai

```js
import { atom, useAtom } from "jotai";

const todosAtom = atom([{ id: 1, done: false }]);

const toggleTodoAtom = atom(null, (get, set, id) => {
	const todos = get(todosAtom);
	const newTodos = todos.map((todo) =>
		todo.id === id ? { ...todo, done: !todo.done } : todo
	);
	set(todosAtom, newTodos); // 직접 불변성 유지
});
```

- 위 예제에서 우리는 기존 배열을 복사하고 `...todo`로 객체도 복사하여 불변성을 수동으로 유지합니다.
- 실수로 원본 배열이나 객체를 직접 수정하게 되면 상태 변경이 감지되지 않거나 예기치 않은 사이드이펙트가 발생할 수 있습니다.

---

### Zustand

Zustand는 선택적으로 [`immer` 미들웨어](https://docs.pmnd.rs/zustand/integrations/immer)를 사용해 불변성 관리를 자동화할 수 있습니다.

```js
import create from "zustand";
import { immer } from "zustand/middleware/immer";

const useStore = create(
	immer((set) => ({
		todos: [{ id: 1, done: false }],
		toggle: (id) =>
			set((state) => {
				const todo = state.todos.find((t) => t.id === id);
				if (todo) todo.done = !todo.done; // 직접 수정해도 안전
			}),
	}))
);
```

- 여기서는 `todo.done = !todo.done`처럼 직접 상태를 변경해도 immer가 자동으로 불변 복사본을 생성합니다.
- 코드가 간결하고 직관적입니다.

---

### Redux

Redux는 기본적으로 상태를 직접 수정하면 안 되며, 불변성을 철저히 지켜야 합니다. 이를 위해 immer를 주로 함께 사용합니다.

```js
import produce from "immer";

const reducer = (state = initialState, action) =>
	produce(state, (draft) => {
		if (action.type === "TOGGLE") {
			const todo = draft.todos.find((t) => t.id === action.id);
			if (todo) todo.done = !todo.done;
		}
	});
```

- immer를 사용해 불변성 유지를 간편하게 하면서도, 전통적인 리듀서 구조를 유지합니다.

---

## 💬 비교 요약

| 라이브러리 | 불변성 관리 방식                             | 자동화 여부                 | 특징                                              |
| ---------- | -------------------------------------------- | --------------------------- | ------------------------------------------------- |
| Jotai      | 직접 객체 복사 및 spread 연산 사용           | ❌ 수동                     | 불변성 개념을 명확히 이해하고 있어야 함           |
| Zustand    | `immer` 미들웨어로 감싸서 내부에서 자동 처리 | ⭕ 선택 가능                | 코드 간결, 실수 줄어듦                            |
| Redux      | 직접 관리하거나 `immer`로 자동화             | ⭕ 대부분 immer와 함께 사용 | 명확한 불변성 규칙 필요, 다소 보일러플레이트 많음 |

---

중간 상태 없이도 파생 상태를 바로 선언 가능:

- selector와 같은 개념 없이, atom 간의 의존성과 파생 구조를 함수형으로 선언할 수 있습니다.
  예를 들어 const doubleAtom = atom((get) => get(countAtom) \* 2) 같은 식으로 별도의 상태 선언 없이 계산된 값을 바로 상태처럼 사용할 수 있다는 점은 Jotai의 강력한 기능입니다.

모든 atom은 Context Provider로 추상화됨:

- 사실상 Jotai는 리액트의 Context API를 내부적으로 적극 활용하여 atom 단위의 상태를 트리 구조에 맞게 구성합니다. 그러나 사용자는 Provider를 명시적으로 다룰 필요 없이, 직관적인 API로 복잡한 상태 트리도 유연하게 관리할 수 있습니다.

비동기 상태도 기본 atom으로 처리 가능:

- Suspense 및 async 함수 반환을 지원하는 atom(async () => …) 패턴이 존재합니다. 이는 별도의 로딩 상태 관리 없이도 비동기 상태를 훅 하나로 자연스럽게 다룰 수 있게 해주는 점에서 큰 장점입니다.

## 결론

Jotai는 상태를 atom 단위로 나누어 각각 독립적으로 관리할 수 있다.

필요에 따라 파생 상태(derived atom)를 정의하고 구독할 atom만 선택할 수 있어 불필요한 리렌더링을 방지하는 데 매우 효과적.

Context 기반의 내부 구조 덕분에 Provider 없이도 안정적인 상태 공유가 가능

또한 상태 훅처럼 간결하게 사용할 수 있으면서도, 배열이나 중첩 객체 상태도 Atoms-in-Atom 패턴을 통해 세밀하게 관리할 수 있다는 점에서 실전 활용도도 높습니다.

그러나 프로젝트 규모가 커지거나 atom이 많아질수록 각 atom의 역할과 의존성을 파악하기 어려워질 수 있고(당연함)

네임스페이스 관리 및 구조적 설계에 대한 고민이 필수적이며, 특히 TypeScript 환경에서는 제네릭 타입 설계가 복잡하게 느껴질 수 있어 러닝 커브가 존재한다는 단점도 함께 고려해야 합니다.
