# 8 - 사용 사례 시나리오 2: Jotai

- 아톰을 모델로 삼는 마이크로 상태 관리 라이브러리
- 상태를 atom 단위로 쪼개서 관리하며, `useAtom()`을 통해 컴포넌트에서 읽고 쓸 수 있다

```tsx
const count1Atom = atom(0);
const count2Atom = atom(0);

const totalAtom = atom((get) => get(count1Atom) + get(count2Atom));
```

- `count1Atom`, `count2Atom`는 각각 독립된 숫자 상태
- `totalAtom`는 의존하고 있는 두 atom의 값을 가져와 합산하는 파생 atom

## Atom의 활성화 시점

- atom은 선언만으로는 메모리에 올라가지 않음
  - 해당 atom이 `useAtom()`으로 처음 읽힐 때 활성화되며, 상태가 메모리에 저장됨
  - 그 이전에는 값이 실제로 존재하지 않음
    - ⇒ 즉, atom은 선언 그 자체로 메모리에 올라가는 것이 아니라, **사용 시점에 활성화**
  - 사용되지 않는 atom은 가비지 컬렉션 대상이 되어 메모리 누수 위험이 낮음

# 렌더링 최적화

atom 단위로 상태가 나뉘어 있기 때문에 불필요한 렌더링을 피할 수 있다

```tsx
const TodoItem = memo(({ todo, ... }) => {
  return (
    <div>
      <input type="checkbox" checked={todo.done} ... />
      <span>{todo.title}</span>
    </div>
  );
});
```

- 배열 전체를 atom으로 관리 → 배열이 바뀔 때마다 이를 구독하는 모든 컴포넌트가 리렌더링
- 각 `Todo` 항목을 개별 atom으로 분리 시, 해당 항목만 리렌더링 되어 성능 최적화 가능
  - `memo()`는 리렌더링 방지를 도와주지만, 상태 구조 자체를 atom 단위로 나누는 것이 더 근본적인 해결책

# Jotai의 상태 저장 방식

`Provider`를 통해 상태 스코프 분리 가능

- 두 `Provider`는 서로 다른 상태 컨텍스트를 가지고 있어 각자 독립적인 값을 유지
- 기본적으로 Jotai는 전역 상태 관리이지만, `Provider`를 사용하면 상태를 로컬 스코프로 분리할 수 있음

```tsx
<Provider>
  <Counter />
</Provider>
<Provider>
  <Counter />
</Provider>
```

- 테스트 코드 등 상태 격리가 필요한 상황에서 유리

# 배열 상태

1. 하나의 배열 atom에 객체 저장

   ```tsx
   const todosAtom = atom<Todo[]>([]);
   ```

   - `setTodos(prev => [...prev, newTodo])`처럼 배열 전체를 업데이트
   - `TodoList`는 배열 전체를 구독하며, 변경될 때마다 전체 렌더링 발생

2. 개별 atom을 배열로 관리

   ```tsx
   const todoAtomsAtom = atom<PrimitiveAtom<Todo>[]>([]);
   ```

   - 각각의 `Todo`를 atom으로 만들고 배열에 담아 관리
   - `TodoItem`은 개별 atom을 구독하므로, 자신이 담당하는 항목만 리렌더링
     - 렌더링 최적화 관점에서 단일 배열 atom보다 낫다

# 사용 패턴

1. Provider를 통한 상태 분리
   - 여러 개의 `Provider`로 동일 atom을 격리할 수 있음
   - 각 provider는 별개의 store를 가지므로 **context와 상태가 모두 분리됨**
2. atom의 파생, 중첩 정의

   ```tsx
   const totalAtom = atom((get) => get(count1Atom) + get(count2Atom));
   ```

   - `get()` 함수로 다른 atom 값을 읽고, 계산된 값을 반환
   - 변경 감지 및 자동 갱신이 이루어짐

3. 컴포넌트 내부 atom 생성 시 주의

   ```tsx
   const myAtom = atom(someValue);
   ```

   - `atom()`은 렌더링 중에 호출하면 안된다
     - 매 렌더링마다 새로운 atom 인스턴스가 생성되기 때문에 불안정한 동작이나 무한 루프 발생
     - 컴포넌트 내에서 동적으로 atom을 생성해야 할 경우, 반드시 `useMemo()`나 `useRef()`를 이용하여 값이 바뀌지 않는 참조를 유지해야 함
