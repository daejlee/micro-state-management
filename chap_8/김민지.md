# 08. 사용 사례 시나리오 2: Jotai

Jotai는 컴포넌트 상태를 사용하며 불변 상태 모델이다.

- useState를 사용한다.
- 객체 속성이 변할 때 객체를 새로 만들어서 변경해야 한다.

<br />

Jotai 특징

- 아톰을 사용하면, 라이브러리가 의존성을 자동으로 추적하고, 의존성에 따라 리렌더링을 한다.
- 내부적으로 컨텍스트를 사용하고, **_아톰 자체는 값을 가지지 않는다_**
  - 따라서 직접 값을 갖는게 아니기 때문에 아톰을 재사용할 수 있다.

## 1. Jotai 이해하기

Jotai의 장점은 크게 두가지가 있다.

1. 구문 단순성
2. 동적 아톰 생성

<br />

Context 예제를 통해 Jotai의 장점을 알아보자.

### 1. 구문 단순성

공유할 상태를 만들 때 Context와 Jotai 예제이다.

> Context

```javascript
// 공급자, Context 만들기
const CounterContext = createContext();
const CounterProvider = () => {
  return (
    <CounterContext.Provider value={useState(0)}>
      {children}
    </CounterContext.Provider>
  );
};

// 상태 사용하기
const Component = () => {
  const [count, setCount] = useContext(CounterContext);
};
```

> Jotai

```javascript
// 아톰 만들기
const countAtom = Atom(0);

// 상태 사용하기
const Component = () => {
  const [count, setCount] = useAtom(countAtom);
};
```

두 예제만 비교해도, Jotai의 atom이 context에 비해 훨씬 단순하다는 것을 알 수 있다.

### 2. 동적 아톰 생성

Jotai의 아톰은 리액트 컴포넌트 생명주기에서 생성되거나 소멸될 수 있다.

- Context에서 새로운 상태를 추가하기

  -> 새로운 Provider를 만든 뒤 컴포넌트들을 감싸기

  -> 트리가 다시 정의되므로 새로 만든 Provider안에 있는 컴포넌트들은 다시 마운트되어 사용했던 상태들이 버려진다.

  ```javascript
  <NewProvider>
    <OldProvider>
      <Count01 />
      <Count02 />
    </OldProvider>
  </NewProvider>
  ```

  - NewProvider로 새로 감싸면 OldProvider, Count01, Count02가 다시 마운트 되고, OldProvider를 통해 사용하고 있던 상태들은 버려진다.

- 새로운 아톰 추가하기
  -> 그냥 하면 됨. 새로운 아톰을 추가한다고 해서 그동안 사용했던 상태들이 버려지거나 하는 것은 아니다.

## 2. 렌더링 최적화

Jotai에서 불필요한 리렌더링을 막는 법

- 사용하는 값만 포함하는 파생 아톰 사용

  ```javascript
  const firstNameAtom = atom("first");
  const lastNameAtom = atom("last");
  const ageAtom = atom(3);

  // first, last name 만 사용하고 싶을 때

  const fullNameAtom = atom((get) => ({
    firstName: get(firstNameAtom),
    lastName: get(lastNameAtom),
  }));
  ```

  - fullNameAtom 을 사용하는 컴포넌트는 firstNameAtom 이나 lastNameAtom 값이 변할때만 리렌더링 된다.

  - 원하는 파생 상태가 객체 형태일 때는 selector를 사용하는 것보다 리렌더링 제어가 간단하다.

    ```javascript
    const store = createStore({
      firstName: "first",
      lastName: "last",
      age: 3,
    });

    const selector = (state) => ({
      firstName: state.firstName,
      lastName: state.lastName,
    });

    const Component = () => {
      const person = useStoreSelector(store, selector);

      return <div>{person.firstName}</div>;
    };
    ```

    - age값이 변하면 Selector가 실행된다. selector는 새로운 객체를 반환한다. 사실상 속성 값이 변한 건 없지만 새로운 객체를 반환했기 때문에 상관없는 age값이 변하여도 리렌더링 된다.

    - 아톰은 그냥 원하는 값만 뽑아서 새로 아톰 만들면 자동으로 의존성(파생 아톰만들때 쓰인 아톰들)이 변경될 때만 값을 갱신함. Good

## 3. Jotai가 아톰 값을 저장하는 법

1. atom값을 저장하는 store가 존재함 (모듈 수준에서 정의된 기본 store가 있음)

   - WeakMap 객체 { 아톰 구성 객체: 아톰 값 }

2. 우리가 생성하는 아톰은 store의 키값(아톰 구성 객체)이라고 생각하면 됨

   - 따라서 우리가 만든 아톰은 그 값을 직접 가지고 있는 것은 아님

3. useAtom[atom] 에서 값은 결국 store(atom)의 값인 것

4. Provider도 사용할 수 있는데 Provider는 새로운 store를 만들어낸다.

   - 그래서 같은 아톰이라도 Provider밖에서 해당 아톰을 사용하는 것과, Provider 하위의 컴포넌트에서 해당 아톰을 사용할때의 값이 다름 (Provider 밖의 store, Provider 내부의 store가 독립적으로 존재하기 때문에 다른 값을 가질 수 있음)

```javascript
const atom1 = atom(1);

const App = () => {
  return (
    <div>
      <AtomComponent /> --- component1
      <Provider>
        <AtomComponent /> --- component2
      </Provider>
    </div>
  );
};

//  App과 같은 상태라면 store는 다음과 같이 2개가 존재한다.
// - 기본 store = {atom1: 1}
// - provider store = {atom1: 1}

const AtomComponent = () => {
  const [atom1, setAtom1] = useAtom(atom1);
  // component1의 경우는 기본 store[atom1]을 가져옴
  // component2의 경우는 provider store[atom1]을 가져옴
  return (
    <div>
      {atom1}
      <button onClick={() => setAtom1((prev) => prev + 1)}>+1</button>
    </div>
  );
};
```

## 4. 배열 구조 추가하기

먼저 atom값으로 배열을 넣을 때 예시는 다음과 같다.

```javascript
const todosAtom = atom([]);

const TodoList = () => {
  const [todos, setTodos] = useAtom(todosAtom);

  const ToggleTodo = useCallback((id: string) =>
    setTodos((prev) =>
      prev.map((item) =>
        item.id === id ? { ...item, done: !item.done } : item
      )
    )
  );

  return (
    <div>
      {todos.map((todo) => (
        <MemoedTodoItem key={todo.id} todo={todo} toggleTodo={toggleTodo} />
      ))}
    </div>
  );
};
```

위 예시의 단점을 살펴보자.

1. 단일 요소를 변경하기 위해서 todos배열 전체를 갱신하게 된다.

2. id값을 key로 사용하지 않는 것이 좋다. (이말은 근데 동의 잘 못함. 이해를 못한걸수도 있음)

이를 해결하기 위한 방법이 **_Atoms-in-Atom_**이다.

Atoms-in-Atom은 간단히 말하면 다음과 같은 방법이다.

ex) Todo[] 아톰을 만들고 싶을때

- Todo 아톰 타입을 먼저 정의한다. type TodoAtom = PrimitiveAtom<Todo>

  - 중요한건 그냥 atom은 아니고 PrimitiveAtom으로 생성함.

- 해당 Todo아톰 배열을 갖는 아톰을 생성한다.ㅋㅋ todoAtomsAtom = atom<TodoAtom[]>([])
  - 결국 이 Atom은 Todo배열이 아니라 TodoAtom배열인 것.

이제 다음과 같이 변경될 수 있다.

```javascript
const todoAtomsAtom = atom<TodoAtom[]>([]);

const TodoList = () => {
  const [todoAtoms, setTodoAtoms] = useAtom(todoAtomsAtom);

  return (
    <div>
      {todoAtoms.map((todoAtom) => (
        <MemoedTodoItem key={`${todoAtom}`} todoAtom={todoAtom}/>
      ))}
    </div>
  );
};

const MemoedTodoItem = memo(({todoAtom}) => {
  const [todo, setTodo] = useAtom(todoAtom)

  const toggleTodo = () => setTodo((prev) => {...prev, done: !prev.done})

  /** 생략 */
})
```

- 하나의 todo가 토글될 때 이전에는 전체 배열을 순회함. 지금은 토글된 아톰만 변경됨 (배열을 순회할 필요 X)

- 하나의 todo가 토글될 때 todos배열이 새로 만들어져서 자식들이 리렌더링 되었음. (물론 memo, key때문에 실제로 리렌더링 되지는 않긴함). 지금은 변경된 todoItem만 리렌더링 됨 (물론 memo, key때문에 실제로 리렌더링 되지는 않긴함)

- 아톰 구성 객체(=atom 반환값)는 하나의 문자열로 평가할 수 있고 UID를 반환한다.
  - UID값이 궁금하다면 케니(이대진)꺼 참고

## 5. Jotai의 다양한 기능 사용하기

(책에 있는 것은 그냥 그대로 두고 다른 방법 적어볼게요)

- reducer와 atom 한번에 정의해서 쓰는 법

```javascript
const reducer = (prev, action) => {
  if (action.type === "inc") return prev + 1;
  else if (action.type === "dec") return prev - 1;
  throw new Error();
};

const countAtom = AtomWithReducer(0:초기값, reducer: 정의한 리듀서)

const Component = () => {
  const [count, dispatch] = useAtom(countAtom)

  return (
  <div>
    {count}
    <button onClick={() => dispatch({ type: 'inc' })}>+1</button>
  </div>)
}
```

- 상태값 스토리지랑 동기화해서 사용하는 법

```javascript
const darkModeAtom = atomWithStorage('darkMode': 스토리지 키, false: 기본값)

const Component = () => {
  const [darkMode, setDarkMode] = useAtom(darkModeAtom)
}

// 기본적으로 로컬 스토리지 씀
```
