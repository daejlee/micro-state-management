# 8. Jotai

Jotai는 전역 상태를 위한 작은 라이브러리로, 컴포넌트 상태를 사용하고, 불변 상태 모델이다. 컨텍스트와 구독 패턴을 기반으로 한다.

`atom`은 하나의 상태를 나타내고, 작은 상태 조각이면서 리렌더링을 감지하는 최소 단위이다.  
`const countAtom = atom(0);` 형식으로 새 아톰(상태)를 만든다.  
컴포넌트 내부에서 `const [count, setCount] = useAtom(countAtom);` 형식으로 생성한 아톰(상태)를 사용할 수 있다.

기존의 컨텍스트로 컴포넌트간의 상태를 공유하는 방식과 비교하여 Jotai는 **구문 단순성**과 **동적 아톰 생성**이라는 이점을 가지고 있다.

### 구문 단순성

**context사용**

```tsx
const CountContext = createContext(
  (undefined as unknown) as [number, Dispatch<SetStateAction<number>>]
);

const CountProvider = ({ children }: { children: ReactNode }) => (
  <CountContext.Provider value={useState(0)}>{children}</CountContext.Provider>
);

const Counter1 = () => {
  const [count, setCount] = useContext(CountContext);
  ...
}

const App = () => (
  <CountProvider>
    <div>
      <Counter1 />
    </div>
    <div>
      <Counter2 />
    </div>
  </CountProvider>
);

```

**Jotai사용**

```tsx
const countAtom = atom(0);

const Counter1 = () => {
  const [count, setCount] = useAtom(countAtom);
  ...
}

const App = () => (
  <>
    <div>
      <Counter1 />
    </div>
    <div>
      <Counter2 />
    </div>
  </>
);
```

컨텍스트를 사용하는 것에 비해 jotai를 사용하는 것이 코드가 더 간단해진다.

아톰을 사용하면 컨텍스트의 **기본 스토어**로 인해 **공급자**가 필요하지 않기 때문이다.

기본적으로 한 줄의 아톰 정의만 추가하면 된다. 반면에 컨텍스트를 사용하면 각 상태마다 컨텍스트를 만들어줘야한다.

다만, jotai를 사용해도 하위 트리에서 각각 다른 값을 제공해야하는 경우 선택적으로 공급자를 사용해야한다.

### 동적 아톰 생성

다중 컨텍스트 방식에서는 새로운 상태 추가 -> 새로운 공급자 컴포넌트 추가를 의미하기에 리액트 컴포넌트 생명 주기에서 생성되거나 소멸되는 것이 불가능하다. 그래서 새로운 컴포넌트를 추가하면 모든 하위 컴포넌트가 다시 마운트되어 해당 상태들이 버려진다.

하지만 아톰은 리액트 컴포넌트 생명주기에서 생성되거나 소멸될 수 있다.  
`useAtom` 훅은 store에 있는 특정 아톰을 구독한다는 것을 의미하며, 이 훅으로 호출 된 아톰은 훅이 호출된 컴포넌트의 생명주기에 따라 자동으로 마운트/언마운트가 이루어지기에 동적 아톰 생성이 가능해진다.

## 렌더링 최적화

store와 셀렉터 접근 방식은 모든 것을 저장하는 store를 생성하고 필요에 따라 store에서 상태를 선택하는 방식이기에 탑다운 방식이다.

하지만 jotai는 바텀업 방식으로 되어있다. 기존 아톰에서 또 다른 아톰을 만들 수 있는 **파생 아톰** 개념이 존재하기 때문이다.

```tsx
const count1Atom = atom(0);
const count2Atom = atom(0);

const Counter = ({ countAtom }: { countAtom: typeof count1Atom }) => {
  const [count, setCount] = useAtom(countAtom);
  const inc = () => setCount((c) => c + 1);
  return (
    <>
      {count} <button onClick={inc}>+1</button>
    </>
  );
};

const totalAtom = atom((get) => get(count1Atom) + get(count2Atom));

const Total = () => {
  const [total] = useAtom(totalAtom);
  return <>{total}</>;
};

const App = () => (
  <>
    (<Counter countAtom={count1Atom} />) + (<Counter countAtom={count2Atom} />) = <Total />
  </>
);
```

`const totalAtom = atom((get) => get(count1Atom) + get(count2Atom));`

이렇게 read함수를 첫번째 인수로 받는 파생 아톰을 생성해서 사용하면 의존성이 변경될 때만 read 함수를 재평가하고 그 값을 갱신한다.

위 코드처럼 사용하게 된다면, `count1Atom`값이 변경된다면 `count2Atom`과는 분리된 상태이기에 `count1Atom`을 사용하는 Counter 컴포넌트와, `count1Atom`을 의존성으로 사용하고 있는 파생아톰인 `totalAtom`을 구독하는 Total 컴포넌트만 리렌더링 될 것이다.

## Atoms-in-Atom

배열상태에 적합한 방식으로, 말 그대로 아톰 안에 아톰을 넣는 형식이다.

```tsx
type Todo = {
  title: string;
  done: boolean;
};

type TodoAtom = PrimitiveAtom<Todo>;

const todoAtomsAtom = atom<TodoAtom[]>([]);

const TodoItem = ({
  todoAtom,
  remove,
}: {
  todoAtom: TodoAtom;
  remove: (todoAtom: TodoAtom) => void;
}) => {
  const [todo, setTodo] = useAtom(todoAtom);
...
}

const MemoedTodoItem = memo(TodoItem);

const TodoList = () => {
  const [todoAtoms, setTodoAtoms] = useAtom(todoAtomsAtom);
  const remove = useCallback(
    (todoAtom: TodoAtom) =>
      setTodoAtoms((prev) => prev.filter((item) => item !== todoAtom)),
    [setTodoAtoms]
  );
  return (
    <div>
      {todoAtoms.map((todoAtom) => (
        <MemoedTodoItem
          key={`${todoAtom}`}
          todoAtom={todoAtom}
          remove={remove}
        />
      ))}
    </div>
  );
};
```

보통이라면 todo객체에 id값을 넣어 map을 사용할 때 각 컴포넌트의 key값으로 넣어줬을 것이다.

하지만 todo객체 타입을 `PrimitiveAtom` 타입으로 감싸 아톰에서 사용할 배열의 타입으로 만들어주고, 이 타입으로 아톰 배열 상태를 만들 수 있다.

이렇게 만들어진 배열 아톰은 아이템 객체가 그대로 문자열로 사용될 때 UID가 생성되기 때문에 id문자열 프로퍼티를 추가하여 따로 관리해줄 필요가 없다.

그리고 이런식으로 배열 아톰을 만들어 사용하면 배열 요소 중 하나가 갱신되더라도 배열 아톰 상태 자체인 `todoAtomsAtom`은 변경되지 않아 리렌더링을 줄일 수 있다.

그냥 배열 상태를 사용했을 때와 **Atoms-in-Atom**패턴을 사용했을 때 차이점을 요약하면 다음과 같다.

- 배열 아톰은 아톰이 요소인 배열을 보관하는 데 사용된다.
- 배열에 새로운 요소를 추가하려면 새로운 아톰을 생성해서 추가해야한다.
- 아톰 구성은 무자열로 평가할 수 있으며 UID를 반환한다.
- 요소를 렌더링하는 컴포넌트는 각 컴포넌트에서 아톰 요소를 사용한다. 이렇게 하면 요소의 값을 쉽게 변경할 수 있고 리렌더링을 피할 수 있다.

