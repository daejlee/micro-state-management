# Jotai

jotai는 atom 기반으로 만들어진 전역 상태관리 라이브러리이다. React의 상태 관리를 단순화하고, 컴포넌트 간의 상태 공유를 쉽게 해준다.

## 구문 단순화

기존에는 Context와 Provider와 useState를 활용해서 전역 상태를 관리했다면, jotai는 atom을 사용하여 상태를 정의하고, 이를 컴포넌트에서 간단하게 사용할 수 있다. atom은 상태의 단위로, jotai에서는 atom을 생성하고 이를 컴포넌트에서 사용하여 상태를 관리한다.

```javascript
import { atom, useAtom } from "jotai";
const countAtom = atom(0);
const Counter = () => {
  const [count, setCount] = useAtom(countAtom);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

기존이었다면

```javascript
import React, { useState, useContext } from "react";
const CountContext = React.createContext();
const CountProvider = ({ children }) => {
  const [count, setCount] = useState(0);
  return (
    <CountContext.Provider value={{ count, setCount }}>
      {children}
    </CountContext.Provider>
  );
};
const Counter = () => {
  const { count, setCount } = useContext(CountContext);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

jotai를 사용하면 훨씬 간단하게 상태를 관리할 수 있다.

## 동적 아톰 생성

jotai는 아톰이 또 다른 아톰을 참조할 수 있는 기능을 제공한다. 이를 통해 동적으로 아톰을 생성하고, 상태를 관리할 수 있다. 예를 들어, 사용자 입력에 따라 아톰을 생성하고, 이를 컴포넌트에서 사용할 수 있다.

```javascript
import { atom, useAtom } from "jotai";

const firstNameAtom = atom("");
const lastNameAtom = atom("");
const ageAtom = atom(0);

const userAtom = atom((get) => ({
  firstName: get(firstNameAtom),
  lastName: get(lastNameAtom),
  age: get(ageAtom),
}));
```

firstNameAtom만 사용하는 컴포넌트는 firstNameAtom만 구독하고, lastNameAtom과 ageAtom은 구독하지 않는다. 이를 통해 불필요한 리렌더링을 방지할 수 있다.

이는 WeakMap을 활용해서 아톰의 스토어가 구현되어있기 때문이다.
그이유를 간단하게 의사 코드로 설명하면 다음과 같다.

```javascript
const store = new WeakMap();
const createAtom = (initialValue) => {
  const atomKey = {};
  const currentAtom = {
    value: initialValue,
    subscribers: new Set(),
  };
  store.set(atomKey, currentAtom);
  return atomKey;
};

const useAtom = (atomKey) => {
  const currentAtom = store.get(atomKey);
  if (!currentAtom) {
    throw new Error("Atom not found");
  }
  // 구독 로직
  return [
    currentAtom.value,
    (newValue) => {
      currentAtom.value = newValue;
      currentAtom.subscribers.forEach((subscriber) => subscriber(newValue));
    },
  ];
};
```

> 💡 왜 store.delete(atom) 같은 메서드가 없는가?
> ✅ WeakMap은 가비지 컬렉션을 지원하기 때문에, 더 이상 참조되지 않는 객체는 자동으로 삭제된다. 따라서 별도로 삭제 메서드를 제공할 필요가 없음!!

## 파생 상태

파생 상태란 기존 상태를 기반으로 새로운 상태를 생성하는 것을 의미한다. jotai에서는 파생 상태를 쉽게 만들 수 있다. 예를 들어, 두 개의 아톰을 합쳐서 새로운 아톰을 만들 수 있다.

```javascript
import { atom, useAtom } from "jotai";
const count1Atom = atom(0);
const count2Atom = atom(0);
const totalAtom = atom((get) => get(count1Atom) + get(count2Atom));
const Counter = () => {
  const [count1, setCount1] = useAtom(count1Atom);
  const [count2, setCount2] = useAtom(count2Atom);
  const [total] = useAtom(totalAtom);
  return (
    <div>
      <p>Count1: {count1}</p>
      <button onClick={() => setCount1(count1 + 1)}>Increment Count1</button>
      <p>Count2: {count2}</p>
      <button onClick={() => setCount2(count2 + 1)}>Increment Count2 </button>
      <p>Total: {total}</p>
    </div>
  );
};
```

## Provider와 Context

Context API처럼 Provider로 전역 상태를 일부 스코프로 제한할 수 있다.

```javascript
import { Provider } from "jotai";

const countAtom = atom(0);
const CountProvider = ({ children }) => {
  return <Provider>{children}</Provider>;
};

const Counter = () => {
  const [count, setCount] = useAtom(countAtom);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};

const App = () => (
  <>
    <CountProvider>
      <Counter />
      <Counter />
    </CountProvider>
    <CountProvider>
      <Counter />
      <Counter />
    </CountProvider>
  </>
);
```

1번, 2번 카운터는 서로 같은 상태를 공유하고,3번, 4번카운터도 서로 같은 상태를 공유한다. 그러나 (1, 2)와 (3, 4)는 서로 다른 상태를 공유한다. 즉, jotai는 Context API처럼 Provider로 전역 상태를 일부 스코프로 제한할 수 있다.

## 다양한 기능 + 미들웨어

atom내 get 외에도 set, args를 활용해서 미들웨어를 구현할 수 있다. 예를 들어, 상태 변경을 로깅하는 미들웨어를 만들 수 있다.

```javascript
import { atom, useAtom } from "jotai";

const countAtom = atom(0, (get, set, newValue) => {
  console.log("State changed from:", get(countAtom), "to:", newValue);
  set(countAtom, newValue);
});

const Counter = () => {
  const [count, setCount] = useAtom(countAtom);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```

`useAtom`외에도 `useAtomValue`, `useSetAtom`, `useUpdateAtom` 훅을 제공하여, 상태를 읽거나 업데이트하는 방법을 다양하게 제공한다. 이를 통해 컴포넌트에서 필요한 상태만 선택적으로 가져오고, 업데이트할 수 있다.

```javascript
import { useAtomValue, useSetAtom } from "jotai";
const countAtom = atom(0);
const Counter = () => {
  const count = useAtomValue(countAtom);
  const setCount = useSetAtom(countAtom);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
};
```
