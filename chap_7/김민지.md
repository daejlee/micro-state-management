# 이번장의 목표 - 사용 사례 시나리오1: Zustand

1. 모듈 상태와 불변 상태 이해하기
2. 리렌더링 최적화를 위한 리액트 훅 추가하기
3. 읽기 상태와 갱신 상태 사용하기
4. 구조화된 데이터 다루기
5. 라이브러리와 접근 방식의 장단점

---

## 1. 모듈 상태와 불변 상태 이해하기

- 모듈 상태: 모듈 수준에서의 상태, 컴포넌트와 독립적으로 존재한다. 자바스크립트 메모리 상에 존재하는 것

- 불변 상태: 상태 객체 속성을 갱신할 수 없고, 상태를 변경하기 위해서는 새 객체를 생성해서 대체하는 것

  - 상태 객체의 참조에 대한 동등성만 확인하면 변경 여부를 알 수 있다.

> Zustand는 (모듈 + 불변) 상태를 사용한다.

+) zustand store의 setState는 새상태와 이전 상태를 병합한다. (= 설정하려는 속성만 지정해도 된다.)

+) zustand store의 subscribe는 store 상태가 변경될 때마다 호출되는 콜백 함수를 등록할 수 있다.

## 2. 리액트 훅을 이용한 리렌더링 최적화

- zustand의 create 함수는 리액트 훅으로 사용될 수 있는 store를 생성한다.

```javascript
// zustand가
export const useStore = create(() => ({ count: 0 }));

const Component = () => {
  // zustand create를 통해 만든 store를 훅으로 사용
  const count = useStore((state) => state.count);
};
```

- zustand에서 화면에 관련있는 값이 변할 때만 리렌더링되도록 하려면 **_선택자 함수_**를 사용해야 한다. (위 예시 참고)

### 선택자 기반 렌더링 최적화

- 장점: 선택자 함수를 명시적으로 작성하여 동작을 정확히 예측할 수 있음
- 단점: 객체 참조에 대한 이해가 필요

## 3. 읽기 상태와 갱신 상태 사용하기

### 상태 읽기

```javascript
// 1. 그냥 읽기, count1아닌 store의 다른 속성 값이 바껴도 리렌더링 됨
const {count1} = useStore()

// 2. 선택자 함수로 원하는 값만 뽑아서 읽기, count1이 바뀔 때만 리렌더링 됨
const count1 = useStore((state) => state.count1)

// 3. 파생된 상태 읽기. 파생된 값이 변할 때만 리렌더링 됨 (count1가 변해도 합이 일정하면 리렌더링 X)
const sum = useStore((state) => state.count1 + state.count2)

// 3-1. 파생된 상태를 스토어에 집어 넣기, 파생 값을 계산하는 것이 복잡할 때 유용
const useStore = create((set) => ({
  count1: 0,
  count2: 0,
  total: 0,
  inc1: () => set((prev) => ({
    count1: prev.count1 + 1
    total: prev.count1 + 1 + prev.count2
  }))
}))
```

### 상태 갱신

- 갱신 상태는 create함수에 setState함수를 인수로 넘겨주어 정의할 수 있다.

```javascript
const useStore = create((set) => ({
  count1: 0,
  count2: 0,
  inc1: () =>
    set((prev) => ({
      count1: prev.count1 + 1;
    })),
  inc2: () =>
    set((prev) => ({
      count2: prev.count2 + 1;
    })),
}));

const Component = () => {
  const count1 = useStore((state) => state.count1)
  const inc1 = useStore((state) => state.inc1)

  return <button onClick={inc1}>{count1}</button>
}
```

## 4. 구조화된 데이터 처리하기

- 투두 애플리케이션 예제를 통해 zustand의 사용법을 알아보자

```javascript
type Todo = {
  id: number,
  title: string,
  done: boolean,
};

type StoreState = {
  todos: Todo[],
  addTodo: (title: string) => void,
  removeTodo: (id: number) => void,
  toggleTodo: (id: number) => void,
};

let nextId = 0;

// create를 통해 store 생성
const useStore =
  create <
  StoreState >
  ((set) => ({
    todos: [],
    addTodo: (title) =>
      set((prev) => ({
        todos: [...prev.todos, { id: ++nextId, title, done: false }],
      })),
    removeTodo: (id) =>
      set((prev) => ({
        todos: prev.todos.filter((e) => e.id !== id),
      })),
    toggleTodo: (id) =>
      set((prev) => ({
        todos: prev.todos.map((todo) =>
          todo.id === id ? { ...todo, done: !todo.done } : todo
        ),
      })),
  }));

// todoItem, todoList에서는 memo로 감싸서 사용함 ex) memo(TodoItem)
const TodoItem = ({ todo }: { todo: Todo }) => {
  const removeTodo = useStore((state) => state.removeTodo);
  const toggleTodo = useStore((state) => state.toggleTodo);

  return (
    <div>
      {todo.title}
      <button onClick={toggleTodo} />
      <button onClick={removeTodo} />
    </div>
  );
};

const todoList = () => {
  const todos = useStore((state) => state.todos);

  // todo값이 변할 때 해당 MemoTodoItem이 리렌더링 됨
  // id가 1인 todo 값이 변하면, todoList, id1인 todo를 받는 MemoTodoItem만 리렌더링되고
  // 나머지 MemoTodoItem은 리렌더링 되지 않음
  return (
    <div>
      {todos.map((todo) => (
        <MemoTodoItem key={todo.id} todo={todo} />
      ))}
    </div>
  );
};
```

## 5. 이 접근 방식과 라이브러리의 장단점

zustand의 읽기 및 쓰기 상태는 다음과 같다.

> 읽기 상태: 선택자 리렌더링 최적화 사용
> 쓰기 상태: 불변 상태 모델 기반 (참조적으로 동잃하면 변하지 않은 것으로 본다.)

### 장점

- 리액트와 동일한 모델 사용으로 라이브러리가 단순함
  - 리액트도 최적화를 위해 객체 불변성 규칙을 사용함

- 번들 크기가 작음 

### 단점

- 선택자를 이용한 수동 렌더링 최적화

- 선택자 사용을 위해 보일러플레이트 코드를 많이 작성해야 함

- 객체 참조 동등성을 이해해야 함

