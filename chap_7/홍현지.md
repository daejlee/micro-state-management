# 7. 사용사례 시나리오 1: Zustand

## Zustand

상태를 유지하는 store를 만드는 데 사용되는 라이브러리

모듈 상태를 위해 설계됐으므로 모듈에서 store를 정의하고 내보내는 것을 할 수 있다.

상태 객체 속성을 갱신할 수 없는 불변 상태 모델을 기반으로 한다. 그렇기에 상태를 변경하기 위해서는 새 객체를 생성해서 대체해야 하며, 수정하지 않은 객체는 재사용한다.

**불변 상태 모델의 장점**: 상태 객체의 참조에 대한 동등성만 확인하면 변경 여부를 알 수 있어 객체의 값 전체를 확인할 필요가 없다.

### Zustand 장단점

**장점**

- 리액트와 동일한 모델을 사용해 라이브러리의 단순성을 가짐
- 번들 크기가 작다

**단점**

- 선택자를 이용한 수동 렌더링 최적화 방식으로, 객체 참조 동등성을 이해해야한다.
- 선택자 코드를 위해 보일러플레이트 코드가 많아진다.

## 모듈 상태와 불변 상태 이해하기

```
import create from "zustand";

// 모듈 상태를 위해 설계됐으므로 모듈에서 store를 정의하고 내보내는 것을 할 수 있다.
type StoreState = {
  count1: number;
  count2: number;
  inc1: () => void;
  inc2: () => void;
};

const useStore = create<StoreState>((set) => ({
  count1: 0,
  count2: 0,
  inc1: () => set((prev) => ({ count1: prev.count1 + 1 })),
  // 상태가 불변성을 가지기에 ++state.count처럼 변경하는 것은 불가능하다. 상태는 반드시 이 set함수처럼 새로운 객체를 이용해 갱신해줘야한다. (함수갱신)
  inc2: () => set((prev) => ({ count2: prev.count2 + 1 })),
}));

const selectCount1 = (state: StoreState) => state.count1;
const selectInc1 = (state: StoreState) => state.inc1;

const Counter1 = () => {
  const count1 = useStore(selectCount1);
  const inc1 = useStore(selectInc1);
  return (
    <div>
      count1: {count1} <button onClick={inc1}>+1</button>
    </div>
  );
};
```

## 리액트 훅을 이용한 리렌더링 최적화

```
const { count, text } = useStore();
```

만약 실제론 count 값만 사용한다고 할 때, 위처럼 사용하면 text가 변경되어도 컴포넌트가 리렌더링 된다.

```
const { count } = useStore((state) => state.count);
```

선택자 함수를 사용하여 count 값만 변경될 때 리렌더링되게 할 수 있다. => **수동 렌더링 최적화**

```
const { count } = useStore((state) => [{count: state.count}]);
```

다만, 이런식으로 새 객체를 포함해 새로운 배열을 생성하는 방식으로 사용하면, count값이 변경되지 않은 경우에도 새로운 배열을 생성하기때문에 컴포넌트가 리렌더링되기에 주의해야한다.

