# 7. Zustand

Zustand(슈스탠드)는 저자가 기여한 상태 관리 라이브러리로, 앞에서 나온 *선택자*로 상태 내부의 일부를 선택하는 방식을 사용한다.

또한 번들사이즈가 다른 상태관리 라이브러리보다 작다. 어느 정도로 작은지 비교해보면 다음과 같다.

- **Zustand**: 약 1.1KB (gzip 기준)
- **Jotai**: 약 2.2KB (gzip 기준)
- **Recoil**: 약 8.5KB (gzip 기준)

왜냐하면 Zustand는 상태를 관리하기 위한 최소한의 API만 제공하기 때문이다. Zustand는 React의 Context API를 사용하지 않고, 상태를 직접적으로 관리하는 방식으로 동작한다. 이로 인해 상태 관리가 더 간단하고, 성능이 향상된다.

Zustand는 상태를 관리하기 위해 *스토어*라는 개념을 사용한다. 스토어는 상태와 상태를 변경하는 함수를 포함하는 객체이다. Zustand는 스토어를 생성하고, 상태를 읽고, 상태를 업데이트하는 간단한 API를 제공한다.

```
import create from 'zustand';
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));
const Component = () => {
  const { count, increment } = useStore();
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
```

또한 Zustand는 여러 상태를 가진 스토어를 합쳐 파생 상태를 만들 수 있는 기능을 제공한다. 이를 통해 상태를 더 세분화하여 관리할 수 있으며, 각 상태는 독립적으로 업데이트될 수 있다. Zustand는 상태를 관리하기 위한 최소한의 API만 제공하기 때문에, 상태 관리가 더 간단하고, 성능이 향상된다.

```
const selectTotal = (state) => state.count1 + state.count2;
const useStore = create((set) => ({
  count1: 0,
  count2: 0,
  increment1: () => set((state) => ({ count1: state.count1 + 1 })),
  increment2: () => set((state) => ({ count2: state.count2 + 1 })),
  total: (state) => selectTotal(state),
}));
const Component = () => {
  const { count1, count2, increment1, increment2, total } = useStore();
  return (
    <div>
      <p>Count1: {count1}</p>
      <button onClick={increment1}>Increment Count1</button>
      <p>Count2: {count2}</p>
      <button onClick={increment2}>Increment Count2</button>
```

이외에도 Zustand는 미들웨어를 지원하여, 상태 업데이트 전후에 추가적인 로직을 실행할 수 있다. 예를 들어, 상태 변경을 로깅하거나, 비동기 작업을 처리하는 등의 작업을 미들웨어를 통해 쉽게 구현할 수 있다. Zustand의 미들웨어는 Redux의 미들웨어와 유사한 개념으로, 상태 관리의 유연성을 높여준다.

가볍다는건 그만큼 대가가 필요하다. 리렌더링 최적화를 사용자가 직접 구현해야 한다. Zustand는 상태를 변경할 때마다 컴포넌트를 리렌더링하기 때문에, 성능 최적화를 위해서는 상태를 선택적으로 구독하는 방법을 사용해야 한다. 이를 위해 Zustand는 `useStore` 훅을 사용하여 상태를 구독하고, 필요한 상태만 선택적으로 가져올 수 있다.
