# 7장. 사용 사례 시나리오 1: Zustand

## 모듈 상태와 불변 상태 이해하기

Zustand는 상태를 유지하는 store를 만드는 데 사용된다.  
이 라이브러리는 **상태 객체 속성을 갱신할 수 없는 불변 상태 모델**을 기반으로 한다.

```tsx
const useCounter = create(() => ({ count: 0 }))

set((state) => ({ count: state.count + 1 }))
```

즉, 상태를 변경하기 위해 새 객체를 생성해서 대체해야 한다.

따라서, store.setState({ count: 2}) 와 같이 갱신을 해야 한다.

## 읽기 상태와 갱신 상태 이용하기

> 리액트 훅을 이용한 리렌더링 최적화는 많이 반복된 내용이라 패스!

Zustand는 다음과 같이 많이 사용하는 것 같다.

```ts
type StoreState = {
  count1: number,
  count2: number,
  inc1: () => void,
  inc2: () => void,
};

const useStore =
  create <
  StoreState >
  ((set) => ({
    count1: 0,
    count2: 0,
    inc1: () => set((prev) => ({ count1: prev.count1 + 1 })),
    inc2: () => set((prev) => ({ count2: prev.count2 + 1 })),
  }))
```

조금 더 복잡하다면, 읽기 상태(상태)와 갱신 상태(액션)를 나눠서 정의하기도 한다.

```ts
type State = {
  count1: number
  count2: number
}

type Actions = {
  inc1: () => void
  inc2: () => void
}

const useStore = create<State & Actions>((set) => ({
  count1: 0,
  count2: 0,
  inc1: () => set((prev) => ({ count1: prev.count1 + 1 })),
  inc2: () => set((prev) => ({ count2: prev.count2 + 1 })),
}))
```

## Zustand 의 장단점

리액트는 객체 불변성을 기반으로 최적화를 진행하는데,  
Zustand 역시 동일한 모델을 사용하고 있다.

따라서, 번들크기가 작고, 사용이 자유롭다. 또한, 리액트 생명주기 외부에서도 쉽게 사용이 가능하다.

하지만, 개발자가 API를 설계하는데 더 고민할 필요가 있고, 코드의 양도 많아지게 된다.  
또, 상태 흐름이 너무 자유로워 사이드이펙트 추적이 어려울 수 있다.

> 그래도 proxy를 이해하는 것 보다는 선택자와 참조 동등성을 이해하는 게 더 낫다고 생각된다.