# 7 - 사용 사례 시나리오 1: Zustand

> 리액트의 모듈 상태를 생성하는 대표적인 라이브러리
> 
- 상태 객체를 직접 수정할 수 없고 항상 새로 만드는, 새로운 상태 객체를 만드는 불변 갱신 모델
    - 객체의 동등성만 비교하여 변경 여부를 알 수 있다는 장점이 있다.
- 렌더링 최적화는 선택자를 사용
- 변경된 상태는 새 객체로 교체하고, 바뀌지 않았다면 기존의 객체를 재사용하여 효율적인 리렌더링

# 모듈 상태와 불변 상태

```tsx
import create from 'zustand';

export const store = create(() => ({ count: 0 }));
```

```tsx
store.setState({ count: 1 });

const state = store.getState();
console.log(store.getState()); // ---> { count: 1 }
```

상태가 불변이기 때문에 `state.count = 2;` 같은 변경 시도는 감지되지 않는다. (동일한 참조)

```tsx
store.setState((prev) => ({ count: prev.count + 1 }));
```

이전 상태를 이용한 갱신도 가능하며 `함수 갱신`이라고 한다.

```tsx
export const store = create(() => ({ 
	count: 0,
	text: "hello",	
}));
```

```tsx
store.setState({
	count: 1,
});
```

- 설정하려는 속성만 변경 가능
- 내부적으로 `Object.assign()`으로 구현되어 새로운 객체로 만들며 기존 객체 내용이 병합된다

```tsx
const unsubscribe = useStore.subscribe((state) => {
  console.log("상태가 바뀜:", state.count);
});

useStore.setState({ count: 1 }); // 콘솔 출력

unsubscribe(); // 구독 해제
```

- 상태가 변경될 때 콜백을 실행하도록 구독 가능
- 상태를 감시하거나 외부 로직을 트리거할 때 유용

# 리액트 훅을 이용한 리렌더링 최적화

```tsx
const { count, text } = useStore();
```

컴포넌트에서 count만 사용하는 경우, text만 변경되어도 리렌더링이 일어난다.

이 경우 선택자를 사용하여 리렌더링 최적화가 가능하다.

```tsx
const { count } = useStore((state) => state.count);
```

# 읽기 상태와 갱신 상태 사용하기

<aside>

읽기 상태: 리렌더링을 최적화하기 위해 선택자 함수 사용

쓰기 상태: 불변 상태 모델 기반

</aside>

```tsx
const selectTotal = (state: StoreState) => state.count1 + state.count2;
```

```tsx
const total = useStore(selectTotal);
```

- 파생 상태에 대한 선택자를 만들어 리렌더링 최적화가 가능
- 이런 경우는 total을 상태에 가지고 있는 것도 좋다.

# middleware

### persist

- 상태를 `localStorage` 등에 저장해서 새로고침해도 유지하게 해준다.
    - 스토어 생성 시, 저장소(localStorage 등)에서 저장된 상태를 먼저 읽어 초기 상태로 사용
    - 따로 저장/복원 코드를 작성할 필요 없이 상태를 자동으로 유지

```tsx
import { persist } from 'zustand/middleware';

const useStore = create(
  persist(
    (set) => ({
      count: 0,
      increment: () => set((state) => ({ count: state.count + 1 })),
    }),
    { name: 'my-storage' }
  )
);
```

### immer

- 상태를 직접 변경하는 것처럼 작성하지만, 내부적으로 불변성을 지켜 새 상태를 만들어준다.
    - 복잡한 불변성 코드를 쓰지 않고도 안전하게 상태를 변경할 수 있다.

```tsx
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

const useStore = create(
  immer((set) => ({
    profile: { name: 'Alice', age: 30 },
    updateName: (name) => set((state) => { state.profile.name = name }),
  }))
);
```

# 장단점

👍: 리액트와 동일 모델 사용, 단순성, 작은 번들 크기

👎: 리렌더링 최적화 시 선택자를 이용한 수동 렌더링 최적화의 번거로움