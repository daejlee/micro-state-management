# 7. Zustand

“슈스텐드”는 리액트 모듈 상태를 생성하도록 설계된 작은 라이브러리다. 상태 객체를 수정하지 않고 새로 만들어야 하는 불변 갱신 모델을 기반으로 한다. 리렌더링 최적화는 selector를 사용해 수동으로 진행한다. 간단하고 강력한 store 생성자 인터페이스가 존재한다.

## 모듈 상태와 불변 상태 이해하기

Zustand는 모듈 상태를 위해 설계되어, 모듈에서 store를 정의하고 내보내는 것을 할 수 있다. 불변 상태 모델 기반이기 때문에 상태 변경은 새 객체를 생성해서 대체하며, 수정하지 않은 객체는 재사용한다.

이 방법의 장점은 상태 객체 참조에 대한 동등성만 확인하면 변경 여부를 알 수 있으므로 객체 값 전체를 일일히 확인할 필요가 없다는 것이다.

```jsx
// 이런 방법은 잘못되었다.
// 새로운 상태가 이전 상태와 동일한 참조를 가지기 때문에 변경 사항을 감지하기 어렵다.
state1.count = 2;

// 새로운 객체를 이용해 갱신해야 한다. 함수를 통해 갱신하는 것도 가능
store.setState((prev) => ({ count: prev.count + 1 })));
```

store.setState()는 새 상태와 이전 상태를 병합하므로, 설정하려는 속성만 지정해도 문제 없다.

```jsx
// ({ count: 1, text: "hello", });
store.setState({
  count: 2,
});

// 내부적으로는 Object.assign()으로 구현됨
Object.assign({}, oldState, newState);
```

store.subscribe를 사용하면 store의 상태가 변경될 때마다 호출되는 콜백 함수를 등록할 수 있다. 이 store.subscribe는 리액트 훅을 구현하기 위한 중요한 함수다.

```jsx
store.subscribe(() => {
  console.log('스토어 상태 변화!');
});
store.setState({ count: 3 }); // "스토어 상태 변화!"
```

4장의 구독을 이용한 모듈 상태 공유와 매우 유사하다.

## 리렌더링 최적화

리렌더링을 피해야 하는 경우 useStore의 셀렉터 함수를 지정할 수 있다.

```jsx
// ({ count: 1, text: "hello", });
// text가 변경되도 리렌더링 되지 않음
const count = useStore((state) => state.count);
return <div>count: {count}</div>;
```

셀렉터 기반 리렌더링 제어를 수동 렌더링 최적화라 한다. 리렌더링 방지를 위해 셀렉터는 셀렉터 함수가 반환하는 결과를 비교하는 식으로 작동한다.

```jsx
// 셀렉터가 새 객체를 포함한 새로운 배열을 생성해 원하는 대로 작동X
// count가 안 바뀌어도 리렌더링된다.
const [{ count }] = useStore((state) => [{ count: state.count }]);
```

## 읽기 상태와 갱신 상태 사용하기

create 함수에 전달되는 store 생성자 함수는 몇 가지 인수를 받는데, 첫 번째가 store의 setState 함수다. 이것으로 store를 정의해보자.

```jsx
type StoreState = {
  count1: number,
  count2: number,
  inc1: () => void,
  inc2: () => void,
};

const useStore =
  create <
  StoreState >
  ((set) => ({
    count1: 0,
    count2: 0,
    inc1: () => set((prev) => ({ count1: prev.count1 + 1 })),
    inc2: () => set((prev) => ({ count2: prev.count2 + 1 })),
  })); // 첫 번째 인수의 이름을 setState의 줄임말인 set으로 지정하는 건 좋은 규칙.
```

```jsx
const selectCount2 = (state: StoreState) => state.count2;
const selectlnc2 = (state: StoreState) => state.inc2;
const Counter2 = () => {
  const count2 = useStore(selectCount2);
  const inc2 = useStore(selectInc2);
  return (
    <div>
      count2: {count2} <button onClick={inc2}>+l</button>
    </div>
  )；
};
```

파생 상태의 생성은 그에 대한 선택자를 사용하면 된다.

```jsx
const countl = useStore(selectCountl);
const count2 = useStore(selectCount2);
return (
  <div>
    total: {countl + count2}
  </div>
);
// 좋긴 한데 count1이 증가하고 count2가 같은 양이 감소하면 리렌더링..
// -> 파생 상태로 해결
const selectTotal = (state: StoreState) => state.count1 + state.count2;
return (
  <div>
    total: {total}
  </div>
);
// 혹은 store에서 합계를 생성할 수도 있다.
// 이러면 결과도 기억하고 많은 컴포넌트가 값을 쓸 때 불필요한 계산을 피한다.
const useStore = create((set) => ({
  countl: 0,
  count2: 0,
  total: 0,
  incl: () => set((prev) => ({
    ...prev,
    countl: prev.count1 + 1,
    total: prev.count1 + 1 + prev.count2,
})),
  inc2: () => set((prev) => ({
    ...prev,
    count2: prev.count2 + 1,
    total: prev.count2 + 1 + prev.count1,
  })),
}))；
```

여러 속성을 동시에 계산하고 동기화 상태를 유지한다.

## 구조화된 데이터 처리하기

위와 같이 단순 숫자를 다루는 예제는 쉽다. 실제는 객체, 배열의 조합을 사용하는 경우가 많다. FE 국룰인 Todo 앱을 만든다고 해보자.

```jsx
type Todo = {
  id: number,
  title: string,
  done: boolean,
};

type StoreState = {
  todos: Todo[], // store 상태에 객체 배열이 들어가는건 일반적이다.
  addTodo: (title: string) => void,
  removeTodo: (id: number) => void,
  toggleTodo: (id: number) => void,
};
```

store 상태에 객체 배열이 들어갔다. 이 부분을 중점적으로 다룬다.

```jsx
let nextId = 0; // 새 할일에 고유 id를 제공하기 위해서 외부에 정의

const useStore =
  create <
  StoreState >
  ((set) => ({
    todos: [],
    addTodo: (title) =>
      set((prev) => ({
        todos: [...prev.todos, { id: ++nextId, title, done: false }],
      })),
    removeTodo: (id) =>
      set((prev) => ({
        todos: prev.todos.filter((todo) => todo.id !== id),
      })),
    toggleTodo: (id) =>
      set((prev) => ({
        todos: prev.todos.map((todo) =>
          todo.id === id ? { ...todo, done: !todo.done } : todo
        ),
      })),
  }));
```

add, remove, toggle 투두 함수를 불변 방식으로 구현한다.

이제 store를 사용하는 컴포넌트를 메모해보자. 불필요한 리렌더링을 피할 수 있다.

- TodoList → todos 배열이 바뀔때마다 리렌더링
- MemoedTodoItem → 해당 todo 항목이 변경될 때만 리렌더링

```jsx
const MemoedTodoItem = memo(TodoItem);

{
  todos.map((todo) => <MemoedTodoItem key={todo.id} todo={todo} />);
}
```

## 이 접근 방식과 라이브러리의 장단점

Zustand의 읽기 및 쓰기 상태는 다음과 같다.

- 읽기 상태: 리렌더링 최적화를 위해 셀렉터를 사용
- 쓰기 상태: 불변 상태 모델을 기반으로 함

중요한 건 리액트가 최적화를 위해 객체 불변성을 기반으로 한다는 점.

```jsx
// countObj = { value: 0 };
const handleClick = () => {
  countObj.value += 1;
  setCount(countObj); // 리렌더링 안 일어남
};
```

Zustand의 상태 모델은 이런 리액트의 객체 불변성 규칙과 정합한다. 이렇게 리액트와 동일한 모델을 사용해 라이브러리의 단순성과 번들 크기가 작다는 점에 큰 이점이 있다.

다만 한계는 셀렉터를 이용한 수동 렌더링 최적화다. 선택자 코드를 위해 보일러플레이트 코드를 많이 작성해야 할 필요가 존재한다.
