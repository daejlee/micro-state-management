# Zustand를 활용한 상태 관리

이 장에서는 마이크로 상태 관리 라이브러리인 **Zustand**를 활용한 실전 중심의 상태 관리 방법을 다룹니다.  
Zustand는 간결한 문법과 뛰어난 성능 최적화 기능을 갖춘 **경량 전역 상태 관리 도구**로, React의 복잡한 상태 공유 문제를 매우 직관적으로 해결해줍니다.

---

## Zustand의 핵심 개념

- `create` 함수를 통해 상태 스토어를 정의하고 훅처럼 사용 가능
- 상태를 **자동으로 불변성 처리 (Immer 내부 내장)**
- `selector`를 통해 **필요한 상태만 부분 구독**
- 상태가 컴포넌트 외부에서도 사용 가능 (예: 비동기 작업, 이벤트 핸들러 등)

---

## 기본 사용법

```js
// store.ts
import create from "zustand";

type State = {
	count: number, // 상태 값
	increment: () => void, // 상태 변경 함수
};

// Zustand 스토어 생성
export const useStore =
	create <
	State >
	((set) => ({
		count: 0,
		increment: () => set((state) => ({ count: state.count + 1 })), // 불변성 자동 처리됨
	}));
```

```js
// Counter.tsx
import { useStore } from "./store";

function Counter() {
	const count = useStore((state) => state.count); // count 값만 구독
	const increment = useStore((state) => state.increment); // 함수도 선택적으로 구독

	return <button onClick={increment}>{count}</button>;
}
```

**설명**  
Zustand는 **Provider 없이 훅 하나로 전역 상태를 정의하고 사용할 수 있는 구조**로, 코드를 매우 단순화시킵니다.  
또한, 부분 구독이 가능해 **리렌더링을 최소화**할 수 있습니다.

---

## 선택자(selector)를 활용한 부분 구독

Zustand는 selector 패턴을 내장하고 있어, 상태 중 특정 값만 구독할 수 있습니다.  
이 방식은 **불필요한 리렌더링을 방지**하는 핵심 전략입니다.

```js
// 필요한 값만 선택해 구독
  onst count = useStore((state) => state.count);
  const increment = useStore((state) => state.increment);
```

- `state.count`만 변경되면 리렌더링되고, 나머지 값이 바뀌어도 영향을 받지 않음
- 리렌더링 단위가 작아질수록 성능 이점이 커짐

---

## 모듈화 예시: 스토어 분리

기능별로 스토어를 나누면 유지보수가 쉬워지고 의존성이 줄어듭니다.

```js
// userStore.ts
import create from "zustand";

type UserState = {
	name: string,
	setName: (name: string) => void,
};

export const useUserStore =
	create <
	UserState >
	((set) => ({
		name: "익명",
		setName: (name) => set({ name }), // 직접 대입으로 상태 갱신
	}));
```

```js
// settingsStore.ts
import create from "zustand";

type SettingsState = {
	darkMode: boolean,
	toggle: () => void,
};

export const useSettingsStore =
	create <
	SettingsState >
	((set) => ({
		darkMode: false,
		toggle: () => set((s) => ({ darkMode: !s.darkMode })), // 이전 상태 기반 토글
	}));
```

이처럼 **기능 단위로 스토어를 나누어 관리**하면, 컴포넌트간 의존성을 줄이고 코드 가독성도 좋아집니다.

---

## 외부 함수에서 Zustand 사용하기

Zustand의 가장 큰 장점 중 하나는, 상태 훅이 일반 함수처럼 동작한다는 점입니다.  
컴포넌트 외부나 비동기 로직에서도 상태를 직접 다룰 수 있습니다.

```js
// api.ts
import { useUserStore } from "./userStore";

export async function fetchAndSetUserName() {
	const setName = useUserStore.getState().setName;
	const response = await fetch("/api/user");
	const data = await response.json();
	setName(data.name); // 컴포넌트 바깥에서 직접 상태 변경
}
```

- `.getState()`를 통해 현재 상태나 상태 변경 함수에 접근 가능
- Redux의 dispatch 없이도 외부에서 쉽게 상태를 다룰 수 있음

## Zustand의 장단점 요약

Zustand는 별도의 Provider 없이도 전역 상태를 간결하게 정의하고 사용할 수 있어 구조가 단순하며, 필요한 값만 선택적으로 구독할 수 있는 selector 기능을 통해 리렌더링을 최소화할 수 있고, 상태 훅이 일반 함수처럼 동작하기 때문에 컴포넌트 외부의 유틸 함수나 비동기 로직에서도 상태를 자유롭게 접근하고 조작할 수 있다는 점에서 높은 유연성과 생산성을 제공합니다. 하지만 Zustand는 상태 관리 방식이 비교적 추상화 수준이 낮기 때문에 내부 동작 원리에 대한 이해가 부족하면 예기치 않은 렌더링 문제나 상태 충돌이 발생할 수 있고, 프로젝트가 커질수록 스토어 간의 역할 분리 및 네임스페이스 관리가 필요해지며, 타입스크립트 사용 시 제네릭 타입 정의와 관련된 진입 장벽이 존재할 수 있다는 점은 고려해야 할 단점입니다.
