## 5장. 리액트 컨텍스트와 구독을 이용한 컴포넌트 상태 공유

### 모듈 상태의 한계

모듈 상태는 전역으로 정의된 싱글턴이기 때문에 컴포넌트 트리나 하위 트리마다 다른 상태를 가질 수 없다.

즉, 동일한 상태를 여러 곳에서 공유하는 것은 가능하나 상황에 따라 분리된 상태는 불가능하다.

> 재사용성이 떨어진다는 의미인가?
번역에 대한 신뢰도가 떨어진 것 같다.
> 

### 컨텍스트와 구독 패턴 사용하기

장점을 조합한다. 

하위 컴포넌트 트리에 대해 복수 상태를 제공하고, 원하는 값의 변화만 감지해 리렌더링한다.

4장에서 만든 `createStore` 를 활용한 `StoreProvider` 그리고 `useSelector` 예시다.

```tsx
type State = { count: number; text?: string };

const StoreContext = createContext<Store<State>>(
  createStore<State>({ count: 0, text: 'hello' })
);

const StoreProvider = ({
  initialState,
  children,
}: {
  initialState: State
  children: ReactNode
}) => {
  const storeRef = useRef<Store<State>>
  if (!storeRef.current) {
    storeRef.current = createStore(initialState)
  }
  
  return (
    <StoreContext.Provider value={storeRef.current}>
      {children}
    </StoreContext.Provider>
  )
}

const useSelector = <S extends unknown> (
  selector: (state: State) => S
) => {
  const store = useContext(StoreContext)
  
  return useSubscription(
    useMemo (
      () => ({
        getCurrentValue: () = selector(store.getState()),
        subscribe: store.subscribe,
      }),
      [store, selector]
    )
  )
}
```

### 정리

불필요한 리렌더링을 막으면서, 필요에 따라 공유되는 상태를 혹은 개별적인 상태를 제공하기 위한 방법이 소개됐다.

이를 활용한 라이브러리를 소개할 것 같다.