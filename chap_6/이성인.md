# 전역 상태 관리 라이브러리 소개

React 훅 기반의 마이크로 전역 상태 라이브러리 도입 전반을 다루며, 각 접근 방식의 특성 및 최적화 전략을 중심으로 정리합니다.

## 전역 상태 관리 문제 해결하기

### 전역 상태를 읽는 방법

전역 상태는 여러 값을 가질 수 있고, 전역 상태를 사용하는 컴포넌트는 전역 상태의 모든 값이 필요하지 않은 경우가 있다. 전역 상태가 바뀌면 리렌더링이 발생하는데, 변경된 값이 컴포넌트와 관련 없는 경우에도 리렌더링이 발생하기 때문이다.
전역 상태 라이브러리는 이에 대한 해결책을 제공해야한다.

### 전역상태를 갱신하는 방법

전역상태는 여러 값을 가질 수 있으며, 그 중 일부는 중첩된 객체일 수 있습니다.
이럴 때 하나의 전역 변수를 가지고 개발자가 직접 값을 변경하는것은 좋지 않은 방법입니다.
이때 변수가 직접 변경될 수 없도록 클로저에서 변수를 숨기는 경우가 있습니다.

## 데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 이해하기

### 데이터 중심 접근 방식

```js
// store.js
let state = { count: 0 };
const listeners = new Set<() => void>();

export function getState() {
  return state;
}

export function setState(newState: typeof state) {
  state = { ...state, ...newState };
  listeners.forEach(listener => listener());
}

export function subscribe(listener: () => void) {
  listeners.add(listener);
  return () => listeners.delete(listener);
}


// Counter.tsx
import { useSyncExternalStore } from "react";
import { getState, setState, subscribe } from "./store";

function Counter() {
  const count = useSyncExternalStore(subscribe, () => getState().count);
  return (
    <button onClick={() => setState({ count: getState().count + 1 })}>
      {count}
    </button>
  );
}
```

데이터 중심 방식은 상태 API가 명확해 구현과 테스트가 간단하고, 리액트 외부에서도 상태를 쉽게 다룰 수 있다는 장점이 있지만, 상태의 범위를 나누기 어렵고 하나의 변경이 모든 컴포넌트에 영향을 줄 수 있다는 단점이 있음.

### 컴포넌트 중심 접근 방식

상태를 컴포넌트 트리 내에서 정의하고 Context.Provider를 통해 범위를 명확히 구분하고 하위 컴포넌트가 useContext 등을 통해 필요한 상태만 구독하며 상태와 UI를 구조적으로 함께 묶을 수 있습니다.

```js
// Store.tsx
const CountContext = React.createContext<[number, React.Dispatch<React.SetStateAction<number>>] | null>(null);

export function CountProvider({ children }: { children: React.ReactNode }) {
  const state = React.useState(0);
  return <CountContext.Provider value={state}>{children}</CountContext.Provider>;
}

export function useCount() {
  const context = React.useContext(CountContext);
  if (!context) throw new Error("useCount must be used within CountProvider");
  return context;
}


// Counter.tsx
import { useCount } from "./Store";

function Counter() {
  const [count, setCount] = useCount();
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

컴포넌트 중심 방식은 상태를 Context와 함께 트리 구조 내에서 명확히 구분할 수 있어 재사용성과 범위 관리에 유리하지만, 초기 설정이 복잡하고 리렌더링 최적화를 신경 써야 하는 단점이 있음.

## 리렌더링 최적화 전략

전역 상태 사용 시 성능 문제를 방지하기 위한 대표적인 최적화 방법은 다음과 같습니다:

```js
// 1. Selector 함수 사용 (부분 구독)
const count = useGlobalState((state) => state.count);

// 2. Proxy 기반 감지 (속성 추적)
const proxyState = new Proxy(state, {
	get(target, prop) {
		// 어떤 속성이 접근되었는지 추적
		return Reflect.get(target, prop);
	},
});

//3. Atom 단위 상태 분리

const countAtom = atom(0);

function Counter() {
	const [count, setCount] = useAtom(countAtom);
	return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```
