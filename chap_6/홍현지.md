# 6. 전역 상태 관리 라이브러리 소개

### 전역 상태 설계 시 문제점

1. 전역 상태를 읽는 방법

- 전역 상태는 여러 값을 가질 수 있고, 전역 상태를 사용하는 컴포넌트는 전역 상태의 모든 값이 필요하지 않을 수 있음

## 전역 상태 유형

### 데이터 중심 접근 방식

- 데이터 모델을 싱글턴으로 먼저 생성 -> 컴포넌트 생성 후 데이터와 컴포넌트 연결

- 데이터 중심 접근 방식은 모듈 상태가 리액트 외부의 자바스크립트 메모리에 있음 -> **모듈 상태를 사용하는 편**이 적합

- 모듈 상태는 리액트의 어떤 시점에서도 존재할 수 있음

- 전역 상태 라이브러리는 모듈 상태를 생성하고 모듈 상태를 리액트 컴포넌트에 연결하는 api 제공

  -> 모듈 상태는 상태 변수에 접근하고 갱신하는 메서드를 가진 store객체로 감싼다.

### 컴포넌트 중심 접근 방식

- 컴포넌트를 먼저 설계할 수 있으며, 보통 상태를 위로 끌어올리고 props로 전달할 수 있음 -> props drilling이 적합하지 않을 시 전역 상태 도입 가능

  > 데이터 모델을 먼저 설계할 수 있으나, 컴포넌트 중심 접근 방식에서는 데이터 모델이 컴포넌트에 강한 의존성을 가짐

- 의존하는 컴포넌트가 모두 마운트 해제가 되면 상태도 사라지기 때문에 컴포넌트 생명 주기 내에서 전역 상태를 유지하는 것이 더 적합함

### 예외

- 데이터 중심, 컴포넌트 중심 접근 방식 중 하나를 사용하거나, 함께 사용할 수 있다.

- 모듈 상태는 대체로 싱글턴 패턴이지만, 하위 트리에 대해 여러 모듈 상태를 만들 수 있고, 모듈 상태의 생명 주기를 제어할 수 있다.  
  -> 하위 트리에 상태를 제공하기 위해 컴포넌트 상태가 사용되기도 하나, 공급자 컴포넌트를 트리 최상위에 두고 트리가 하나만 있으면 싱글턴 패턴으로 봄

- 컴포넌트 상태는 대체로 `useState` 훅으로 구현되지만, 변수나 `useRef` 훅으로도 구현 가능

## 리렌더링 최적화

전역 상태에서 리렌더링을 피하는 것이 중요

### 선택자 함수 사용

선택자 함수는 상태를 받아 상태의 일부를 반환한다.

```
const value = useSelector((state)=>state.b.c);
```

이런식으로 쓴다면 value를 쓰는 컴포넌트는 `state.b.c`에만 관심이 있고, `state` 객체의 다른 값이 변경 되어도 `state.b.c` 가 변경되지 않으면 리렌더링되지 않는다.

선택자 함수는 유연해서 상태의 일부 뿐 아니라 파생된 값도 반환 가능하다.

선택자 함수는 컴포넌트의 어느 부분을 사용할지 명시적으로 지정하는 방법이기에 **수동 최적화** 라고 한다.

### 속성 접근 감지

**상태 사용 추적**: 속성 접근을 감지하고 감지한 정보를 렌더링 최적화에 사용 가능

```
const trackedState = useTrackedState();
return <p>{trackedState.b.c}</p>;
```

예를 들어, 상태 사용 추적 기능이 있는 useTrackedState 훅이 있다고 가정하면, 해당 훅을 통해 컴포넌트에서 `.b.c` 속성에 접근했음을 감지할 수 있고, `.b.c`속성이 변경될 때만 리렌더링을 발생시킨다.  
=> **자동 최적화**

`useTrackedState`를 구현하려면 상태 객체에 대한 속성 접근을 확인하기 위한 프록시가 필요하다.

`useSelector`훅으로 같은 동작을 수행하도록 구현을 할 순 있으나 접근하는 속성들이 많아지면 메모이제이션이나 사용자지정 비교 함수와 같은 복잡한 기법이 필요하기에 쉽지 않다.

성능이나 편의성으로 보았을 때 `useTrackedState`가 우세하나 `useSelector`가 적합한 경우도 있다.

- `useSelector`는 파생 값을 만들 수 있기에 상태를 더 간단한 값을 만들 수 있다.

```
const isSmall = useSelector((state)=>state.a<10); // state.a<10으로 인해 isSmall 값이 변경될 때만 리렌더링
const isSmall2 = useTrackedState().a < 10; // state.a가 변경될 때마다 리렌더링
```

### 아톰 사용

**아톰**: 리렌더링을 발생시키는 데 사용되는 최소 상태 단위

```
const state = {
  a: atom(1),
  b: atom(2),
  c: atom(3)
}
```

아톰이 완전히 분리되어있다면 state내에서 별도의 전역 상태를 갖는 것과 같다고 볼 수 있다.

아톰을 사용하는 접근 방식은 수동 최적화와 자동 최적화의 중간 정도이다. -> 아톰과 파생 값의 정의는 명시적이지만 의존성 추적은 자동으로 된다.
