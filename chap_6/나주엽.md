# 6장. 전역 상태 관리 라이브러리 소개

## 전역 상태 관리 문제 해결하기

리액트와 같은 컴포넌트 기반 구조는 지역 상태 관리에서의 강점을 가지지만,  
여러 컴포넌트 간 공유되어야 하는 상태가 필요한 경우, 전역 상태 관리가 필요해진다.

전역 상태는 컴포넌트에 대한 추가적인 의존성을 부여하는 것이기 때문에  
가능한 피하는 것이 좋겠지만, 어쩔 수 없는 경우도 있다.

전역 상태를 설계할 때는 두 가지 문제점이 있다.

- 전역 상태를 읽는 방법  
  전역 상태 변경 → 리렌더링 발생 → 변경된 값이 컴포넌트와 관련이 없는 경우 **“리렌더링 최적화 필요”**
- 전역 상태 값을 갱신하는 방법  
  중첩된 객체의 **변경 사항을 잘 감지**할 방법 필요

## 데이터 중심 vs 컴포넌트 중심

데이터 중심 접근 방식은, 상태를 도메인 단위로 나누어서 설계하는 것이고, 앱 전역에서 이를 공유해 사용하는 것이다.  
ex) 로그인/인증 정보를 담는 전역 상태 등

컴포넌트 중심은 보다 지역 상태를 효과적으로 사용하는 형태로, 상태를 컴포넌트 생명 주기 내에서만 유지하는 것이다.  
ex) LMB 의 열림/닫힘 상태 등

> 다크모드를 관리하는 상태는 어디에 더 적함한가?

## 리렌더링 최적화

- 선택자 함수
- 속성 접근 감지
- 아톰 사용

우선, **선택자 함수**를 사용하는 대표 라이브러리는 Zustand, Recoil 이 있다.  
상태 전체가 아닌 특정 부분만 구독하는 방식이며,   
상태 객체의 참조가 변경되더라도, selector 를 통한 반환 값이 같으면 리렌더되지 않도록 하는 것이 특징이다.

**속성 접근 방식**은 선택자를 사용해 명시적으로 상태를 지정하지 않고도 렌더링 최적화를 수행하는 방식이다.  
Valtio, react-tracked 가 대표 라이브러리이다.  
선택자가 아닌 프록시를 통해 속성에 대한 접근을 확인한다고 한다.

Valtio 의 예시는 이렇다.

```tsx
import { proxy, useSnapshot } from 'valtio'

const state = proxy({ user: { name: 'name' }, count: 1 }) // 상태를 proxy로 감싸고,
const snap = useSnapshot(state) // useSnapshot 으로 접근한다.

const Component = () => {
  const snap = useSnapshot(state)
  return <div>{snap.user.name}</div>
}
```

위 컴포넌트는 user.name만 읽었기 때문에,  count가 변경되어도 리렌더링 되지 않는다.  
proxy() 내부적으로는, 어떤 속성을 어떤 컴포넌트에서 읽었는지 기록해두고,   
상태의 값이 변할 때, 그 속성을 썼던 컴포넌트들을 리렌더링 하도록 만든다고 한다.

프록시가 어떻게 구현되어 있나 궁금해서 지피티선생님께 물어봤다.

```tsx
// 개념적으로 이런 흐름
const accessedProps = new Set()

const proxy = new Proxy(target, {
  get(target, prop) {
    accessedProps.add(prop) // 어떤 속성이 읽혔는지 기록
    return Reflect.get(target, prop)
  },
  set(target, prop, value) {
    const changed = Reflect.set(target, prop, value)
    // prop이 실제로 바뀌었고, 구독자 중 해당 prop을 읽은 컴포넌트가 있다면
    if (accessedProps.has(prop)) {
      triggerReRender(prop)
    }
    return changed
  }
})
```

아톰은 Recoil, Jotai 등이 대표적인데,  
모든 전역 상태를 세분화해서 만들어놓고, 구독해서 사용하는 것이다.