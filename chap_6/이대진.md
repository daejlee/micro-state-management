# 6. 전역 상태 관리 라이브러리 소개

전역 상태의 특성을 이해하기 위해 전역 상태와 관련된 문제와 “상태가 위치하는 곳”과 “리렌더링을 제어하는 방법”이라는 두 측면에 대해 먼저 알아본다.

## 전역 상태 관리 문제 해결하기

- 전역 상태를 읽는 방법
  전역 상태를 사용하는 컴포넌트는 전역 상태의 모든 값이 필요하지 않을 수 있다. 전역 상태가 바뀜에 따라 일어나는 리렌더링을 최적화 해야 한다.
- 전역 상태에 값을 넣거나 갱신하는 방법
  하나의 전역 변수를 가지고 직접 값을 변경하는 건 좋지 않다. 그냥 리렌더링이 안됨. 따라서 상태 변경을 감지하기 위해 전역 상태를 변경하는 함수를 제공해야 한다. 클로저에서 변수를 숨길 수도 있다. (createContainer)

<aside>

    💡범용 상태 관리? 상태 관리의 개념적인 것을 의미하는 것 같은데 검색해도 잘 안 나온다. 아는 사람?

</aside>

## 데이터 중심 접근 방식 / 컴포넌트 중심 접근 방식

전역 상태를 데이터 중심 / 컴포넌트 중심의 두 유형으로 나눌 수 있다.

### 데이터 중심

데이터 모델을 싱글턴으로 가지고 컴포넌트 정의 후 데이터와 연결한다.

모듈 상태가 리액트 외부 JS 메모리에 존재해 모듈 상태가 적합하다. 이런 데이터 중심 접근을 사용하는 전역 상태 라이브러리는 모듈 상태를 생성하고 모듈 상태를 리액트 컴포넌트에 연결하는 API를 제공한다. 이는 보통 상태 변수에 접근하고 갱신하는 메서드를 가진 “store’ 객체로 감싼다.

이 모듈 상태는 리액트 렌더링과 컴포넌트 마운트 해제에 관계 없이 존재할 수 있다. 즉 리액트랑 별 상관이 없이 독립적이다.

### 컴포넌트 중심

컴포넌트를 먼저 설계한다. 특정 시점에 컴포넌트가 공유 정보에 접근한다. 이 방식에선 데이터 모델이 컴포넌트에 강한 의존성을 가진다.

컴포넌트 생명 주기 내에 전역 상태를 유지하는게 더 적합하다. 데이터 중심의 방식과 다르게 의존 컴포넌트가 다 마운트 해제되면 전역 상태도 함께 사라진다. (가비지 컬렉팅인가? 마크 앤 스윕이 생각나네요?) 이를 활용해 JS 메모리에 두 개 이상의 동일한 전역 상태를 둘 수 있는데, 각 상태가 서로 다른 컴포넌트 하위 트리에 존재하기 때문. (독립된-동일한 두 전역 상태가 존재할 수 있다는 말 같다)

이런 방식에선 팩토리 함수를 제공하고 전역 상태를 초기화 하는 함수를 생성한다. 팩토리 함수는 직접 전역 상태를 생성하지 않고, 생성된 함수로 리액트가 전역 상태의 생명 주기를 처리하도록 한다.

## 리렌더링 최적화

핵심은 컴포넌트에서 상태의 어느 부분이 사용될지 지정하는 것이다. 이를 지정하는 몇 가지 접근 방식이 있는데, 각 방식을 살펴본다.

### Selector 함수 사용

상태를 받아 일부를 반환한다. 익숙하지 않은가? 이전에 나왔던 패턴이다.

```jsx
const value = useSelector((state) => state.b.c);
return <>{value}</>;
```

useSelector는 상태 변경마다 selector 함수의 결과를 비교하는데 사용된다. 따라서 동일한 입력이 주어질 때 state를 참조해 동일한 결과를 반환하는 것이 중요하다.

selector 함수는 컴포넌트의 어느 부분을 쓸지 명시적으로 지정하므로 수동 최적화라고 한다.

### 속성 접근 감지

selector 없이 렌더링 최적화를 자동 수행할 수 있나? 속성 접근을 감지하고 감지한 정보를 렌더링 최적화에 사용할 수 있는 상태 사용 추적(state usage tracking)이라는 것이 있다. (이거 된다고? ㅋㅋ)

```jsx
const trackedState = useTrackedState();
return <p>{trackedState.b.c}</p>;
```

훅을 통해 trackedState가 .b.c에 접근했음을 감지하고, 그에 따라 리렌더링한다.

이를 구현하려면 상태 객체에 대한 속성 접근을 확인하기 위해 프록시가 필요한데, 이를 제대로 구현하면 useSelector를 대부분 대체한다. 다만 자동 렌더링 최적화가 완벽하게 작동하지 않는 경우가 있다.

```jsx
// isSmall이 변경될 때만 리렌더링
const isSmall = useSelector((state) => state.a < 10);
return <>{isSmall ? 'small' : 'big'}</>;

// state.a가 변경될 때마다 리렌더링
const isSmall = useTrackedState().a < 10;
return <>{isSmall ? 'small' : 'big'}</>;
```

useSelector는 파생 값에도 대응이 가능하여 상태를 더 간단하게 만들 수 있다.

<aside>

    💡useSelector가 파생 값에 대해서 리렌더링 최적화가 가능하다는 걸 포인트로 기억하면 좋을듯?

</aside>

### 아톰 사용

아톰은 리렌더링을 발생시키는 최소 상태 단위다. 세분화해서 구독하는 개념이다.

```jsx
const globalState = {
  a: atom(1),
  b: atom(2),
  e: atom(3),
};
// 아톰이 완전 분리되있다면 별도 전역 상태를 갖는 것과 거의 같다.
const value = useAtom(globalState.a);
return <>{value}</>;
// 근데 만약 아톰을 엮어서 파생 상태를 만드려고 하면?
const sum = globalState.a + globalState.b + globalState.c;
// 이거 하려면 디펜던시 추적해서 아톰 갱신마다 다시 평가해야댐.
```

아톰 접근방식은 수동~자동 최적화의 중간이다. 아톰과 파생 값의 정의가 명시적이지만 의존성 추적은 자동이다.

<aside>

    💡파생 값을 어떻게 대하는지가 각 라이브러리의 주요 차이점으로 작용할 수 있을듯.

</aside>
