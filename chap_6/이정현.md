# 6 - 전역 상태 라이브러리 소개

전역 상태 라이브러리를 알아보기 전, 6장에서는 전역 상태의 특성을 이해하기 위해 다음 3가지를 먼저 다룬다.

1. 전역 상태와 관련된 문제
2. 전역 상태를 저장하는 위치
3. 리렌더링 최적화

# 전역 상태 관리의 문제점과 해결책

1️⃣ 전역 상태가 일부 변경되어도, 관련 없는 값만 사용하는 컴포넌트까지 불필요하게 리렌더링될 수 있다. 

2️⃣ 전역 상태는 중첩된 객체와 같이 복잡한 상태일 수 있기 때문에, 하나의 전역 변수를 통해 직접 값을 변경하는 것은 좋지 않을 수 있다.

- 값을 직접 변경하는 경우 리렌더링을 감지할 방법이 없으므로, 변경하는 함수를 제공해야 한다.
- 변수가 직접 변경되는 것을 막기 위해 클로저에 변수를 숨기는 경우도 있다.

```tsx
const createContainer = () => {
  let state = { a:1, b:2};
  const getState = () => state;
  const setState = (...) => {...};
  return {getState, setState};
};

const globalContainer = createContainer();
globalContainer.setState(...);
```

- 대부분의 상태 관리 라이브러리는 직접 변수를 변경하는 것을 금지하거나 권장하지 않는, 클로저로 숨기기 원칙을 준수하지만 MobX, Valtio는 상태를 직접 변경하는 방식을 허용한다.
    - Proxy로 상태를 감싸서 변경을 감시하는 방식으로, 값이 변경되면 이를 감지한다.
    
    ```tsx
    const state = { count: 0 };
    
    const proxyState = new Proxy(state, {
      set(target, prop, value) {
        target[prop] = value;
        console.log(`${prop}가 ${value}로 변경됨`);
        // 여기서 리렌더링 트리거 같은 작업 가능
        return true;
      }
    });
    
    proxyState.count = 1;  // console: count가 1로 변경됨
    ```
    

# 전역 상태의 두 가지 유형

1️⃣ 데이터 중심 접근 방식

- 데이터의 흐름을 바탕으로 상태를 먼저 설계하는 방식
- 외부에서 데이터를 변경하는 것도 가능
- 데이터의 흐름과 변경이 UI에 묶이지 않기 때문에, 외부 모듈에서 상태를 만들고 컴포넌트는 그걸 구독해서 사용하는 패턴이 자연스럽다.
- Redux, Zustand 등 전역 상태 라이브러리에서 흔하게 쓰는 방식으로 모듈 상태를 컴포넌트에 연결하는 API를 제공하고, 변수에 접근하는 메서드를 가진 store 객체로 감싼 형태
    - 팩토리 함수를 제공하고, 전역 상태를 초기화하는 함수를 생성 (상태의 생명 주기 처리 목적)

2️⃣ 컴포넌트 중심 접근 방식

- UI의 동작을 바탕으로 컴포넌트를 먼저 설계하는 방식
- 데이터가 컴포넌트에 강한 의존성을 가지고 있다.
    - 따라서 컴포넌트 생명 주기 내에서 전역 상태를 유지하는 것이 적합하다.
    - Recoil, Jotai의 경우 구독자가 모두 사라질 때 상태도 제거되도록 처리하는 매커니즘을 가진다.
- 주로 props drilling을 피하고 컴포넌트 간 상태 공유를 간단하게 하기 위한 전역 상태 이용

---

`리렌더링 최적화`의 핵심은 state의 어느 부분을 사용할 지 정하는 것에 있으며, 그 3가지 방식을 살펴본다.

1. 선택자 함수 사용
2. 속성 접근 감지
3. 아톰 사용

# 선택자 함수

> 전역 상태에서 필요한 값만 골라오는 함수
> 

```tsx
const value = useSelector((state) => state.b.c);
```

- 정확히 상태의 어떤 값을 사용하는지 명시하는 함수 (수동 최적화)
- 명시한 값이 변경되지 않는다면 리렌더링이 발생하지 않는다.
- 객체를 반환하는 경우에는 메모이제이션을 사용하여 항상 같은 객체 참조를 반환하도록 해야 한다.

# 속성 접근 감지

> 상태 사용 추적을 통한 상태 변경 감지
> 

```tsx
const trackedState = useTrackedState();
```

- `trackedState.b.c` 와 같이 접근 시 감지
- 필요한 값을 지정할 필요 없이 자동 최적화
- 상태 객체에 대한 속성 접근을 확인하기 위한 Proxy 필요
- 파생 값에 대한 변경 여부가 필요한 경우 선택자 함수를 사용하는 것이 좋다.

# 아톰

> 리렌더링을 발생시키는 최소 상태 단위
> 
- 아톰이 분리되어 있다면 별도의 전역 상태로 본다.

```tsx
const globalState = {
	a: atom(1),
	b: atom(2),
};
```

- 파생 값의 정의는 명시적이지만 의존성 추적은 자동으로 된다.

```tsx
import { atom } from 'jotai';

const countAtom = atom(1);
const doubleAtom = atom((get) => get(countAtom) * 2);
```

- 내부적으로 `doubleAtom`이 `countAtom`에 의존하고 있다는 걸 자동 추적하여 `countAtom`이 바뀌면 `doubleAtom`도 자동으로 재계산