# 이번장의 목표

1. 전역 상태 관리 문제 해결하기
2. 데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 이용하기
3. 리렌더링 최적화

---

## 1. 전역 상태 관리 문제 해결 하기

전역 상태 관리의 문제점 

### 1. 전역 상태를 읽는 방법

변경된 값이 컴포넌트와 관련이 없는 경우에도 리렌더링이 발생할 수 있다.

전역 상태 라이브러리는 ***리렌더링 최적화***를 통해 불필요한 리렌더링을 피해야 한다.


### 2. 전역 상태에 값을 넣거나 갱신하는 방법

전역 상태 라이브러리는 개발자가 직접 상태를 변경할 수 없도록 ***상태를 변경하는 함수***를 제공해야 한다.


## 2. 데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 사용하기

### 데이터 중심 접근 방식

> 컴포넌트를 정의한 후 데이터와 컴포넌트를 연결하는 방법

- 모듈 상태를 사용하기 때문에 리액트가 렌더링을 시작하기 전이나 컴포넌트가 마운트 해제된 후에도 존재할 수 있다.

### 컴포넌트 중심 접근 방식

> 주로 컴포넌트를 먼저 설계함, 데이터 모델이 컴포넌트에 강한 의존성을 가짐

- 컴포넌트 생명주기 내에서 전역 상태를 유지한다. (= 컴포넌트가 모두 마운트 해제되면 전역 상태도 사라진다.)

- 컴폰넌트 상태를 사용한다.

## 3. 리렌더링 최적화

### 선택자 함수 사용

- 선택자 함수가 상태를 받아 상태 일부만 반환하는 방법

- 장점: 파생값을 만들 수 있다.

```javascript
// a + b의 합이 변할 때만 컴포넌트가 리렌더링된다.
const sum = useSelector((state) => state.a + state.b)
```

- ***수동 렌더링 최적화***

### 속성 접근 감지

- 속성 접근을 감지하고 사용된 속성 값이 변경될때만 리렌더링 발생시키는 방법

- 웬만하면 이 방법이 선택자 방법보다 낫지만, 파생 값에 대해서는 선택자 함수가 더 적합할 수 있다.

- ***자동 렌더링 최적화***

### 아톰 사용

- 리렌더링을 발생시키는 데 사용되는 최소 상태 단위

- 전체 전역 상태를 구독하는 것이 아니라 세부적으로 구독하는 것

```javascript
const globalState = {
  a: atom(1),
  b: atom(2)
}
```

- ***수동 렌더링 최적화와 자동 렌더링 최적화의 중간***

  - 아톰과 파생값의 정의는 명시적이지만, 의존성 추적은 자동으로 됨
