# 1. 리액트 훅을 이용한 마이크로 상태 관리

상태 관리는 프론트엔드 개발에서 필수적인 요소이며, 일반적으로는 전역 상태 관리 라이브러리(예: Redux, MobX)를 통해 중앙 집중적으로 관리해 왔다. 그러나 리액트 훅의 등장 이후로는 이러한 방식에 의존하지 않고도 컴포넌트 단위의 경량 상태 관리, 즉 마이크로 상태 관리가 가능해졌다.

마이크로 상태 관리는 각 컴포넌트가 자신의 목적에 맞는 상태를 관리하도록 하는 목적 지향적인 접근법이다. 전통적인 상태 관리 방식보다 코드의 응집도를 높이고, 테스트 및 유지보수를 단순화할 수 있다는 장점이 있다.

## 마이크로 상태 관리 이해하기

리액트에서 “상태(state)”란 UI에 영향을 미치는 모든 데이터를 의미한다. 상태는 시간이 지남에 따라 변할 수 있으며, 리액트는 이 상태의 변화를 감지해 컴포넌트를 다시 렌더링한다. 이러한 상태를 목적에 맞게, 필요한 위치에서만 관리하는 것이 마이크로 상태 관리의 핵심이다.

이러한 방식이 효과적으로 작동하기 위해서는 다음 조건이 충족되어야 한다

- 상태를 읽을 수 있어야 하며
- 상태를 갱신할 수 있어야 하고
- 상태 변경에 따라 컴포넌트가 자동으로 다시 렌더링되어야 한다

리액트 훅은 이러한 조건을 충족시키기 위해 만들어진 기본 API들을 제공한다. 특히 useState, useReducer, useEffect는 마이크로 상태 관리에서 핵심적인 역할을 수행한다.

### 리액트 훅 사용하기

리액트 훅이 등장하면서 가장 크게 달라진 점 중 하나는 UI 컴포넌트 내부에서 로직을 추출해 재사용 가능하게 만들 수 있다는 점이다.

예를 들어 다음과 같이 상태 관리 로직을 별도의 훅으로 분리할 수 있다:

```jsx
const useCount = () => {
	const [count, setCount] = useState(0);
	return [count, setCount];
};

const Component = () => {
	const [count, setCount] = useCount();

	return (
		<div>
			{count}
			<button onClick={() => setCount((c) => c + 1)}>+1</button>
		</div>
	);
};
```

이렇게 구성하면 다음과 같은 이점이 있다

- 의도를 명확하게 표현할 수 있다. useCount라는 이름만으로 해당 훅의 역할을 명확히 알 수 있다.
- 로직을 재사용할 수 있다. 동일한 상태 관리 로직이 필요한 컴포넌트에서 useCount를 호출하면 동일한 동작을 쉽게 구현할 수 있다.
- 컴포넌트와 로직이 분리된다. 로직을 변경하거나 확장할 때 컴포넌트를 수정하지 않아도 된다.

### 리액트 훅의 순수성 규칙

리액트 훅과 컴포넌트 함수는 여러 번 호출될 수 있기 때문에 부작용 없는 순수 함수처럼 동작해야 한다. 이를 위해 다음과 같은 규칙이 존재한다:

state 또는 ref는 직접 변경하지 않고 제공된 setter로만 갱신해야 한다.

컴포넌트 함수 및 훅은 항상 같은 순서로 호출되어야 하며, 조건문 내부에서 호출되면 안 된다.

이러한 규칙을 위반하면 동시성 렌더링(Concurrent Rendering) 또는 서스펜스(Suspense)와 같은 리액트의 고급 기능에서 문제가 발생할 수 있다.

### 전역 상태

전역 상태는 애플리케이션 전반에 걸쳐 여러 컴포넌트가 공유하는 상태를 의미한다. 종종 전역 상태를 공유 상태(shared state)라고 부르기도 하는데, 이는 단일 인스턴스 싱글톤을 의미하지는 않는다.

리액트의 컴포넌트 모델은 **지역성(locality)**을 강조한다. 즉, 컴포넌트는 서로 격리되어 있어야 하며, 가능한 독립적이어야 한다. 이로 인해 리액트는 전역 상태를 직접 다루기 위한 메커니즘을 제공하지 않는다. 대신 전역 상태를 효과적으로 다루기 위해 별도의 전략 또는 외부 도구가 필요하다.

컴포넌트는 함수처럼 재사용 가능한 단위이며, 재사용을 위해서는 외부 상태에 대한 의존을 최소화해야 한다. 전역 상태에 과도하게 의존하면 컴포넌트의 일관성과 재사용성이 크게 저하될 수 있다.

### 지연 초기화(lazy init)

useState는 지연 초기화를 위해 함수 형태의 초기값도 받을 수 있다. 이 함수는 컴포넌트 마운트 시 한 번만 호출된다.

```jsx
const init = () => {
	console.log("무거운 계산");
	return 0;
};

const [count, setCount] = useState(init);
```

무거운 초기 계산 로직을 효율적으로 수행할 수 있다는 장점이 있다.

### 베일아웃

useReducer는 이전과 동일한 상태를 반환하면 리렌더링이 발생하지 않는다:

```jsx
case 'SET_TEXT':
  if (!action.text) {
    return state; // 베일아웃
  }
  return { ...state, text: action.text };
```

객체의 참조가 바뀌지 않으면 리액트는 렌더링을 생략한다. 따라서 불필요한 객체 생성은 피해야 한다.

원시 값도 가능
useReducer는 객체뿐만 아니라 원시 값 상태도 처리할 수 있다:

```jsx
const reducer = (count, delta) => {
	if (delta < 0) throw new Error("Invalid delta");
	return count + delta;
};

const [count, dispatch] = useReducer(reducer, 0);
```

이처럼 복잡한 로직을 외부에서 관리할 수 있다는 점은 테스트 가능성과 유지보수 측면에서 큰 이점을 제공한다.

### reducer에서의 지연 초기화

useReducer는 init이라는 세 번째 인자를 통해 지연 초기화를 지원한다.

```jsx
const init = (initialCount) => ({ count: initialCount, text: "" });

const [state, dispatch] = useReducer(reducer, 0, init);
```

마운트 시 한 번만 실행되므로 무거운 연산을 효율적으로 처리할 수 있다.

### useState와 useReducer 에서의 상태관리 요약

이처럼 useState와 useReducer는 서로 유사한 점이 많지만, 복잡성과 목적에 따라 적절히 선택해야 한다. 간단한 값 관리에는 useState를, 상태 변경 로직이 복잡하거나 외부화가 필요한 경우에는 useReducer를 사용하는 것이 권장된다.
